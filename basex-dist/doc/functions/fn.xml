<functions name="Standard" pref="fn">
  <function name="node-name" type="xs:QName?">
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the name of a node, as an <code>xs:QName</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the empty sequence
is returned.</rule>
    <rule>Otherwise, the function returns the result of the
<code>dm:node-name</code> accessor as defined in <a href="#">[xpath-datamodel]</a> (see <a href="http://www.w3.org/TR/xpath-datamodel/#dm-node-name">Section 5.11
node-name Accessor</a>
      <sup>
        <small>DM</small>
      </sup>).</rule>
  </function>
  <function name="nilled" type="xs:boolean?">
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns true for an element that is <b>nilled</b>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise the function returns the result of the
<code>dm:nilled</code> accessor as defined in <a href="#">[xpath-datamodel]</a> (see <a href="http://www.w3.org/TR/xpath-datamodel/#dm-nilled">Section 5.9
nilled Accessor</a>
      <sup>
        <small>DM</small>
      </sup>).</rule>
  </function>
  <function name="string" type="xs:string">
    <signature/>
    <signature>
      <arg name="arg" type="item()?"/>
    </signature>
    <summary>Returns the value of <code>$arg</code> represented as an
<code>xs:string</code>.</summary>
    <rule>In the zero-argument version of the function, <code>$arg</code>
defaults to the context item. That is, calling
<code>fn:string()</code> is equivalent to calling
<code>fn:string(.)</code>.</rule>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the zero-length string.</rule>
    <rule>If <code>$arg</code> is a node, the function returns the
string-value of the node, as obtained using the
<code>dm:string-value</code> accessor defined in <a href="#">[xpath-datamodel]</a> (see <a href="http://www.w3.org/TR/xpath-datamodel/#dm-string-value">Section
5.13 string-value Accessor</a>
      <sup>
        <small>DM</small>
      </sup>).</rule>
    <rule>If <code>$arg</code> is an atomic value, the function returns
the result of the expression <code>$arg cast as xs:string</code>
(see <a href="#casting">
        <b>18 Casting</b>
      </a>).</rule>
  </function>
  <function name="data" type="xs:anyAtomicType*">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns the result of atomizing a sequence, that is, replacing
all nodes in the sequence by their typed values.</summary>
    <rule>The result of <code>fn:data</code> is the sequence of atomic
values produced by applying the following rules to each item in
<code>$arg</code>:</rule>
  </function>
  <function name="base-uri" type="xs:anyURI?">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the base URI of a node.</summary>
    <rule>The zero-argument version of the function returns the base URI
of the context node: it is equivalent to calling
<code>fn:base-uri(.)</code>. This may result in an error being
raised: if the context item is undefined [<a href="http://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup>
        <small>XP</small>
      </sup>; if
the context item is not a node [<a href="http://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup>
        <small>XP</small>
      </sup>.</rule>
    <rule>The single-argument version of the function behaves as
follows:</rule>
    <rule>See also <a href="#func-static-base-uri">
        <code>fn:static-base-uri</code>
      </a>.</rule>
  </function>
  <function name="document-uri" type="xs:anyURI?">
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the URI of a resource where a document can be found, if
available.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>If <code>$arg</code> is not a document node, the function
returns the empty sequence.</rule>
    <rule>Otherwise, the function returns the value of the
<code>document-uri</code> accessor applied to <code>$arg</code>, as
defined in <a href="#">[xpath-datamodel]</a> (See <a href="http://www.w3.org/TR/xpath-datamodel/#DocumentNodeAccessors">Section
6.1.2 Accessors</a>
      <sup>
        <small>DM</small>
      </sup>).</rule>
  </function>
  <function name="error" type="none">
    <signature/>
    <signature>
      <arg name="code" type="xs:QName"/>
    </signature>
    <signature>
      <arg name="code" type="xs:QName?"/>
      <arg name="description" type="xs:string"/>
    </signature>
    <signature>
      <arg name="code" type="xs:QName?"/>
      <arg name="description" type="xs:string"/>
      <arg name="error-object" type="item()*"/>
    </signature>
    <summary>Calling the <code>fn:error</code> function raises an
application-defined error.</summary>
    <rule>This function never returns a value. Instead it always raises an
error. The effect of the error is identical to the effect of
dynamic errors raised implicitly, for example when an incorrect
argument is supplied to a function.</rule>
    <rule>The parameters to the <code>fn:error</code> function supply
information that is associated with the error condition and that is
made available to a caller that asks for information about the
error. The error may be caught either by the host language (using a
try/catch construct in XSLT or XQuery, for example), or by the
calling application or external processing environment. The way in
which error information is returned to the external processing
environment is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>
    </rule>
    <rule>If <code>fn:error</code> is called with no arguments, then its
behavior is the same as the function call:</rule>
    <rule>If <code>$code</code> is the empty sequence then the effective
value is the <code>xs:QName</code> constructed by:</rule>
    <rule>There are three pieces of information that may be associated
with an error:</rule>
    <example>
      <code>fn:error()</code> returns
<code>http://www.w3.org/2005/xqt-errors#FOER0000</code> (or the
corresponding <code>xs:QName</code>) to the external processing
environment, unless the error is caught using a try/catch construct
in the host language.</example>
    <example>
      <code>fn:error(fn:QName('http://www.example.com/HR',
'myerr:toohighsal'), 'Does not apply because salary is too
high')</code> returns
<code>http://www.example.com/HR#toohighsal</code> and the
<code>xs:string</code> <code>"Does not apply because salary is too
high"</code> (or the corresponding <code>xs:QName</code>) to the
external processing environment, unless the error is caught using a
try/catch construct in the host language.</example>
  </function>
  <function name="trace" type="item()*">
    <signature>
      <arg name="value" type="item()*"/>
      <arg name="label" type="xs:string"/>
    </signature>
    <summary>Provides an execution trace intended to be used in debugging
queries.</summary>
    <rule>The function returns the value of <code>$value</code>,
unchanged.</rule>
    <rule>In addition, the values of <code>$value</code>, converted to an
<code>xs:string</code>, and <code>$label</code>
<strong>may</strong> be directed to a trace data set. The
destination of the trace output is <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a>. The format of the trace output is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>. The ordering of output from calls of the
<code>fn:trace</code> function is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <example>Consider a situation in which a user wants to investigate the
actual value passed to a function. Assume that in a particular
execution, <code>$v</code> is an <code>xs:decimal</code> with value
<code>124.84</code>. Writing <code>fn:trace($v, 'the value of $v
is:')</code> will put the strings <code>"124.84"</code> and
<code>"the value of $v is:"</code> in the trace data set in
implementation dependent order.</example>
  </function>
  <function name="abs" type="numeric?">
    <signature>
      <arg name="arg" type="numeric?"/>
    </signature>
    <summary>Returns the absolute value of <code>$arg</code>.</summary>
    <rule>General rules: see <a href="#numeric-value-functions">
        <b>4.4
Functions on Numeric Values</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is negative the function returns
<code>-$arg</code>, otherwise it returns <code>$arg</code>.</rule>
    <rule>If the type of <code>$arg</code> is one of the four numeric
types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the
result is the same as the type of <code>$arg</code>. If the type of
<code>$arg</code> is a type derived from one of the numeric types,
the result is an instance of the base numeric type.</rule>
    <rule>For <code>xs:float</code> and <code>xs:double</code> arguments,
if the argument is positive zero or negative zero, then positive
zero is returned. If the argument is positive or negative infinity,
positive infinity is returned.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_abs_ceil_floor_round">
Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and
fn:round-half-to-even functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>The expression <code>fn:abs(10.5)</code> returns
<code>10.5</code>.</example>
    <example>The expression <code>fn:abs(-10.5)</code> returns
<code>10.5</code>.</example>
  </function>
  <function name="ceiling" type="numeric?">
    <signature>
      <arg name="arg" type="numeric?"/>
    </signature>
    <summary>Rounds <code>$arg</code> upwards to a whole number.</summary>
    <rule>General rules: see <a href="#numeric-value-functions">
        <b>4.4
Functions on Numeric Values</b>
      </a>.</rule>
    <rule>The function returns the smallest (closest to negative infinity)
number with no fractional part that is not less than the value of
<code>$arg</code>.</rule>
    <rule>If the type of <code>$arg</code> is one of the four numeric
types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the
result is the same as the type of <code>$arg</code>. If the type of
<code>$arg</code> is a type derived from one of the numeric types,
the result is an instance of the base numeric type.</rule>
    <rule>For <code>xs:float</code> and <code>xs:double</code> arguments,
if the argument is positive zero, then positive zero is returned.
If the argument is negative zero, then negative zero is returned.
If the argument is less than zero and greater than -1, negative
zero is returned.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_abs_ceil_floor_round">
Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and
fn:round-half-to-even functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>The expression <code>fn:ceiling(10.5)</code> returns
<code>11</code>.</example>
    <example>The expression <code>fn:ceiling(-10.5)</code> returns
<code>-10</code>.</example>
  </function>
  <function name="floor" type="numeric?">
    <signature>
      <arg name="arg" type="numeric?"/>
    </signature>
    <summary>Rounds <code>$arg</code> downwards to a whole number.</summary>
    <rule>General rules: see <a href="#numeric-value-functions">
        <b>4.4
Functions on Numeric Values</b>
      </a>.</rule>
    <rule>The function returns the largest (closest to positive infinity)
number with no fractional part that is not greater than the value
of <code>$arg</code>.</rule>
    <rule>If the type of <code>$arg</code> is one of the four numeric
types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the
result is the same as the type of <code>$arg</code>. If the type of
<code>$arg</code> is a type derived from one of the numeric types,
the result is an instance of the base numeric type.</rule>
    <rule>For <code>xs:float</code> and <code>xs:double</code> arguments,
if the argument is positive zero, then positive zero is returned.
If the argument is negative zero, then negative zero is
returned.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_abs_ceil_floor_round">
Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and
fn:round-half-to-even functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>The expression <code>fn:floor(10.5)</code> returns
<code>10</code>.</example>
    <example>The expression <code>fn:floor(-10.5)</code> returns
<code>-11</code>.</example>
  </function>
  <function name="round" type="numeric?">
    <signature>
      <arg name="arg" type="numeric?"/>
    </signature>
    <signature>
      <arg name="arg" type="numeric?"/>
      <arg name="precision" type="xs:integer"/>
    </signature>
    <summary>Rounds a value to a specified number of decimal places, rounding
upwards if two such values are equally near.</summary>
    <rule>General rules: see <a href="#numeric-value-functions">
        <b>4.4
Functions on Numeric Values</b>
      </a>.</rule>
    <rule>The function returns the nearest (that is, numerically closest)
value to <code>$arg</code> that is a multiple of ten to the power
of minus <code>$precision</code>. If two such values are equally
near (for example, if the fractional part in <code>$arg</code> is
exactly .5), the function returns the one that is closest to
positive infinity.</rule>
    <rule>If the type of <code>$arg</code> is one of the four numeric
types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the
result is the same as the type of <code>$arg</code>. If the type of
<code>$arg</code> is a type derived from one of the numeric types,
the result is an instance of the base numeric type.</rule>
    <rule>The single-argument version of this function produces the same
result as the two-argument version with <code>$precision=0</code>
(that is, it rounds to a whole number).</rule>
    <rule>When <code>$arg</code> is of type <code>xs:float</code> and
<code>xs:double</code>:</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_abs_ceil_floor_round">
Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and
fn:round-half-to-even functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>The expression <code>fn:round(2.5)</code> returns
<code>3.0</code>.</example>
    <example>The expression <code>fn:round(2.4999)</code> returns
<code>2.0</code>.</example>
    <example>The expression <code>fn:round(-2.5)</code> returns
<code>-2.0</code>. <em>(Not the possible alternative,
<code>-3</code>).</em>
    </example>
    <example>The expression <code>fn:round(1.125, 2)</code> returns
<code>1.13</code>.</example>
    <example>The expression <code>fn:round(8452, -2)</code> returns
<code>8500</code>.</example>
    <example>The expression <code>fn:round(3.1415e0, 2)</code> returns
<code>3.14e0</code>.</example>
  </function>
  <function name="round-half-to-even" type="numeric?">
    <signature>
      <arg name="arg" type="numeric?"/>
    </signature>
    <signature>
      <arg name="arg" type="numeric?"/>
      <arg name="precision" type="xs:integer"/>
    </signature>
    <summary>Rounds a value to a specified number of decimal places, rounding
to make the last digit even if two such values are equally
near.</summary>
    <rule>General rules: see <a href="#numeric-value-functions">
        <b>4.4
Functions on Numeric Values</b>
      </a>.</rule>
    <rule>The function returns the nearest (that is, numerically closest)
value to <code>$arg</code> that is a multiple of ten to the power
of minus <code>$precision</code>. If two such values are equally
near (e.g. if the fractional part in <code>$arg</code> is exactly
.500...), the function returns the one whose least significant
digit is even.</rule>
    <rule>If the type of <code>$arg</code> is one of the four numeric
types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the
result is the same as the type of <code>$arg</code>. If the type of
<code>$arg</code> is a type derived from one of the numeric types,
the result is an instance of the base numeric type.</rule>
    <rule>The first signature of this function produces the same result as
the second signature with <code>$precision=0</code>.</rule>
    <rule>For arguments of type <code>xs:float</code> and
<code>xs:double</code>:</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_abs_ceil_floor_round">
Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and
fn:round-half-to-even functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>The expression <code>fn:round-half-to-even(0.5)</code> returns
<code>0.0</code>.</example>
    <example>The expression <code>fn:round-half-to-even(1.5)</code> returns
<code>2.0</code>.</example>
    <example>The expression <code>fn:round-half-to-even(2.5)</code> returns
<code>2.0</code>.</example>
    <example>The expression <code>fn:round-half-to-even(3.567812e+3,
2)</code> returns <code>3567.81e0</code>.</example>
    <example>The expression <code>fn:round-half-to-even(4.7564e-3, 2)</code>
returns <code>0.0e0</code>.</example>
    <example>The expression <code>fn:round-half-to-even(35612.25, -2)</code>
returns <code>35600</code>.</example>
  </function>
  <function name="format-integer" type="xs:string">
    <signature>
      <arg name="value" type="xs:integer?"/>
      <arg name="picture" type="xs:string"/>
    </signature>
    <signature>
      <arg name="value" type="xs:integer?"/>
      <arg name="picture" type="xs:string"/>
      <arg name="language" type="xs:language"/>
    </signature>
    <summary>formats an integer according to a given picture string, using
the conventions of a given natural language if specified.</summary>
    <rule>If <code>$value</code> is an empty sequence, the function
returns a zero-length string.</rule>
    <rule>In all other cases, the <code>$picture</code> argument describes
the format in which <code>$value</code> is output.</rule>
    <rule>The rules that follow describe how non-negative numbers are
output. If the value of <code>$value</code> is negative, the rules
below are applied to the absolute value of <code>$value</code>, and
the result is prepended with a minus sign.</rule>
    <rule>A picture consists of a primary format token, followed by an
optional format modifier.</rule>
    <rule>The primary format token is one of the following:</rule>
    <rule>For all format tokens other than the first kind above (one that
consists of decimal digits), there <strong>may</strong> be
<a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a> lower and upper bounds on the range of numbers
that can be formatted using this format token; indeed, for some
numbering sequences there may be intrinsic limits. For example, the
format token <code>&amp;#x2460;</code> (circled digit one, ①) has a
range of 1 to 20 imposed by the Unicode character repertoire. For
the numbering sequences described above any upper bound imposed by
the implementation <strong>must not</strong> be less than 1000 (one
thousand) and any lower bound must not be greater than 1. Numbers
that fall outside this range <strong>must</strong> be formatted
using the format token <code>1</code>.</rule>
    <rule>The above expansions of numbering sequences for format tokens
such as <code>a</code> and <code>i</code> are indicative but not
prescriptive. There are various conventions in use for how
alphabetic sequences continue when the alphabet is exhausted, and
differing conventions for how roman numerals are written (for
example, <code>IV</code> versus <code>IIII</code> as the
representation of the number 4). Sometimes alphabetic sequences are
used that omit letters such as <code>i</code> and <code>o</code>.
This specification does not prescribe the detail of any sequence
other than those sequences consisting entirely of decimal
digits.</rule>
    <rule>Many numbering sequences are language-sensitive. This applies
especially to the sequence selected by the tokens <code>w</code>,
<code>W</code> and <code>Ww</code>. It also applies to other
sequences, for example different languages using the Cyrillic
alphabet use different sequences of characters, each starting with
the letter #x410 (Cyrillic capital letter A). In such cases, the
<code>$language</code> argument specifies which language's
conventions are to be used; it has the same range of values as
<code>xml:lang</code> (see <a href="#REC-xml">[REC-xml]</a>). If no
<code>$language</code> argument is specified, the language that is
used is <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a>. The set of languages for which numbering is
supported is <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a>. If a language is requested that is not
supported, the processor uses the language that it would use if the
<code>$language</code> argument were omitted.</rule>
    <rule>The format modifier, if present, is one of:</rule>
    <rule>If the <code>o</code> modifier is present, this indicates a
request to output ordinal numbers rather than cardinal numbers. For
example, in English, when used with the format token
<code>1</code>, this outputs the sequence <code>1st 2nd 3rd 4th
...</code>, and when used with the format token <code>w</code>
outputs the sequence <code>first second third fourth
...</code>.</rule>
    <rule>In some languages, ordinal numbers vary depending on the
grammatical context, for example they may have different genders
and may decline with the noun that they qualify. In such cases the
string appearing in parentheses after the letter <code>o</code> may
be used to indicate the variation of the ordinal number required.
The way in which the variation is indicated will depend on the
conventions of the language. For inflected languages that vary the
ending of the word, the preferred approach is to indicate the
required ending, preceded by a hyphen: for example in German,
appropriate values are <code>o(-e)</code>, <code>o(-er)</code>,
<code>o(-es)</code>, <code>o(-en)</code>.</rule>
    <rule>It is <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a> what combinations of values of the format
token, the language, and the <code>ordinal</code> attribute are
supported. If ordinal numbering is not supported for the
combination of the format token, the language, and the string
appearing in parentheses, the request is ignored and cardinal
numbers are generated instead.</rule>
    <rule>The <code>t</code> modifier disambiguates between numbering
sequences that use letters. In many languages there are two
commonly used numbering sequences that use letters. One numbering
sequence assigns numeric values to letters in alphabetic sequence,
and the other assigns numeric values to each letter in some other
manner traditional in that language. In English, these would
correspond to the numbering sequences specified by the format
tokens <code>a</code> and <code>i</code>. In some languages, the
first member of each sequence is the same, and so the format token
alone would be ambiguous. By default the alphabetic sequence is
used; the <code>t</code> modifier requests the other sequence.</rule>
    <example>The expression <code>format-integer(123, '0000')</code> returns
<code>"0123"</code>.</example>
    <example>
      <code>format-integer(123, 'w')</code> might return <code>"one
hundred and twenty-three"</code>
    </example>
    <example>The expression <code>format-integer(21, '1o', 'en')</code>
returns <code>"21st"</code>.</example>
    <example>
      <code>format-integer(14, 'Wwo(-e)', 'de')</code> might return
<code>"Vierzehnte"</code>
    </example>
    <example>The expression <code>format-integer(7, 'a')</code> returns
<code>"g"</code>.</example>
    <example>The expression <code>format-integer(57, 'I')</code> returns
<code>"LVII"</code>.</example>
  </function>
  <function name="format-number" type="xs:string">
    <signature>
      <arg name="value" type="numeric?"/>
      <arg name="picture" type="xs:string"/>
    </signature>
    <signature>
      <arg name="value" type="numeric?"/>
      <arg name="picture" type="xs:string"/>
      <arg name="decimal-format-name" type="xs:string"/>
    </signature>
    <summary>Returns a string containing a number formatted according to a
given picture string, taking account of decimal formats specified
in the static context.</summary>
    <rule>The function formats <code>$value</code> as a string using the
<a title="picture string" class="termref" href="#dt-picture-string">
        <span class="arrow">·</span>picture
string<span class="arrow">·</span>
      </a> specified by the
<code>$picture</code> argument and the decimal-format named by the
<code>$decimal-format-name</code> argument, or the default
decimal-format, if there is no <code>$decimal-format-name</code>
argument. The syntax of the picture string is described in <a href="#syntax-of-picture-string">
        <b>4.6.3 Syntax of the Picture
String</b>
      </a>.</rule>
    <rule>The <code>$value</code> argument may be of any numeric data type
(<code>xs:double</code>, <code>xs:float</code>,
<code>xs:decimal</code>, or their subtypes including
<code>xs:integer</code>). Note that if an <code>xs:decimal</code>
is supplied, it is not automatically promoted to an
<code>xs:double</code>, as such promotion can involve a loss of
precision.</rule>
    <rule>If the supplied value of the <code>$value</code> argument is an
empty sequence, the function behaves as if the supplied value were
the <code>xs:double</code> value <code>NaN</code>.</rule>
    <rule>The value of <code>$decimal-format-name</code>
<strong>must</strong> be a lexical QName, which is expanded using
the in-scope namespaces from the static context. The default
namespace is not used (no prefix means no namespace).</rule>
    <rule>The evaluation of the <code>format-number</code> function takes
place in two phases, an analysis phase described in <a href="#analysing-picture-string">
        <b>4.6.4 Analysing the Picture
String</b>
      </a> and a formatting phase described in <a href="#formatting-the-number">
        <b>4.6.5 Formatting the
Number</b>
      </a>.</rule>
    <rule>The analysis phase takes as its inputs the <a title="picture string" class="termref" href="#dt-picture-string">
        <span class="arrow">·</span>picture
string<span class="arrow">·</span>
      </a> and the variables derived
from the relevant decimal format in the static context, and
produces as its output a number of variables with defined values.
The formatting phase takes as its inputs the number to be formatted
and the variables produced by the analysis phase, and produces as
its output a string containing a formatted representation of the
number.</rule>
    <rule>The result of the function is the formatted string
representation of the supplied number.</rule>
  </function>
  <function name="codepoints-to-string" type="xs:string">
    <signature>
      <arg name="arg" type="xs:integer*"/>
    </signature>
    <summary>Creates an <code>xs:string</code> from a sequence of <a href="#Unicode4">[The Unicode Standard]</a> codepoints.</summary>
    <rule>The function returns the string made up from the characters
whose Unicode codepoints are supplied in <code>$arg</code>. This
will be the zero-length string if <code>$arg</code> is the empty
sequence.</rule>
    <example>The expression <code>fn:codepoints-to-string((2309, 2358, 2378,
2325))</code> returns <code>"अशॊक"</code>.</example>
  </function>
  <function name="string-to-codepoints" type="xs:integer*">
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Returns the sequence of <a href="#Unicode4">[The Unicode
Standard]</a> codepoints that constitute an <code>xs:string</code>
value.</summary>
    <rule>The function returns a sequence of integers, each integer being
the Unicode codepoint of the corresponding character in
<code>$arg</code>.</rule>
    <rule>If <code>$arg</code> is a zero-length string or the empty
sequence, the function returns the empty sequence.</rule>
    <example>The expression <code>fn:string-to-codepoints("Thérèse")</code>
returns <code>(84, 104, 233, 114, 232, 115, 101)</code>.</example>
  </function>
  <function name="compare" type="xs:integer?">
    <signature>
      <arg name="comparand1" type="xs:string?"/>
      <arg name="comparand2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="comparand1" type="xs:string?"/>
      <arg name="comparand2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns -1, 0, or 1, depending on whether
<code>$comparand1</code> collates before, equal to, or after
<code>$comparand2</code> according to the rules of a selected
collation.</summary>
    <rule>Returns -1, 0, or 1, depending on whether the value of the
<code>$comparand1</code> is respectively less than, equal to, or
greater than the value of <code>$comparand2</code>, according to
the rules of the collation that is used.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>If either <code>$comparand1</code> or <code>$comparand2</code>
is the empty sequence, the function returns the empty sequence.</rule>
    <rule>This function, called with the first signature, defines the
semantics of the "eq", "ne", "gt", "lt", "le" and "ge" operators on
<code>xs:string</code> values.</rule>
    <example>The expression <code>fn:compare('abc', 'abc')</code> returns
<code>0</code>.</example>
    <example>The expression <code>fn:compare('Strasse', 'Straße')</code>
returns <code>0</code>. <em>(Assuming the default collation
includes provisions that equate "ss" and the (German) character "ß"
("sharp-s"). Otherwise, the returned value depends on the semantics
of the default collation.).</em>
    </example>
    <example>The expression <code>fn:compare('Strasse', 'Straße',
'http://example.com/deutsch')</code> returns <code>0</code>.
<em>(Assuming the collation identified by the URI
<code>http://example.com/deutsch</code> includes provisions that
equate "ss" and the (German) character "ß" ("sharp-s"). Otherwise,
the returned value depends on the semantics of that
collation.).</em>
    </example>
    <example>The expression <code>fn:compare('Strassen', 'Straße')</code>
returns <code>1</code>. <em>(Assuming the default collation
includes provisions that treat differences between "ss" and the
(German) character "ß" ("sharp-s") with less strength than the
differences between the base characters, such as the final "n".
).</em>
    </example>
  </function>
  <function name="codepoint-equal" type="xs:boolean?">
    <signature>
      <arg name="comparand1" type="xs:string?"/>
      <arg name="comparand2" type="xs:string?"/>
    </signature>
    <summary>Returns true if two strings are equal, considered
codepoint-by-codepoint.</summary>
    <rule>If either argument is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns <code>true</code> or
<code>false</code> depending on whether the value of
<code>$comparand1</code> is equal to the value of
<code>$comparand2</code>, according to the Unicode codepoint
collation
(<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</rule>
  </function>
  <function name="concat" type="xs:string">
    <signature>
      <arg name="arg1" type="xs:anyAtomicType?"/>
      <arg name="arg2" type="xs:anyAtomicType?"/>
    </signature>
    <summary>Returns the concatenation of the string values of the
arguments.</summary>
    <rule>This function accepts two or more <code>xs:anyAtomicType</code>
arguments and casts each one to <code>xs:string</code>. The
function returns the <code>xs:string</code> that is the
concatenation of the values of its arguments after conversion. If
any argument is the empty sequence, that argument is treated as the
zero-length string.</rule>
    <rule>The <code>fn:concat</code> function is specified to allow two or
more arguments, which are concatenated together. This is the only
function specified in this document that allows a variable number
of arguments. This capability is retained for compatibility with
<a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>.</rule>
    <example>The expression <code>fn:concat('un', 'grateful')</code> returns
<code>"ungrateful"</code>.</example>
    <example>The expression <code>fn:concat('Thy ', (), 'old ', "groans", "",
' ring', ' yet', ' in', ' my', ' ancient',' ears.')</code> returns
<code>"Thy old groans ring yet in my ancient ears."</code>.</example>
    <example>The expression <code>fn:concat('Ciao!',())</code> returns
<code>"Ciao!"</code>.</example>
    <example>The expression <code>fn:concat('Ingratitude, ', 'thou ',
'marble-hearted', ' fiend!')</code> returns <code>"Ingratitude,
thou marble-hearted fiend!"</code>.</example>
  </function>
  <function name="string-join" type="xs:string">
    <signature>
      <arg name="arg1" type="xs:string*"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string*"/>
      <arg name="arg2" type="xs:string"/>
    </signature>
    <summary>Returns a string created by concatenating the items in a
sequence, with a defined separator between adjacent items.</summary>
    <rule>The effect of calling the single-argument version of this
function is the same as calling the two-argument version with
<code>$arg2</code> set to a zero-length string.</rule>
    <rule>The function returns an <code>xs:string</code> created by
concatenating the items in the sequence <code>$arg1</code>, in
order, using the value of <code>$arg2</code> as a separator between
adjacent items. If the value of <code>$arg2</code> is the
zero-length string, then the members of <code>$arg1</code> are
concatenated without a separator.</rule>
    <example>The expression <code>fn:string-join(('Now', 'is', 'the', 'time',
'...'), ' ')</code> returns <code>"Now is the time ..."</code>.</example>
    <example>The expression <code>fn:string-join(('Blow, ', 'blow, ', 'thou
', 'winter ', 'wind!'), '')</code> returns <code>"Blow, blow, thou
winter wind!"</code>.</example>
    <example>The expression <code>fn:string-join((), 'separator')</code>
returns <code>""</code>.</example>
    <example>Assume a document:</example>
    <example>with the <code>&lt;section&gt;</code> element as the context
node, the <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>
expression:</example>
    <example>
      <code>fn:string-join(ancestor-or-self::*/name(), '/')</code>
    </example>
    <example>returns <code>"doc/chap/section"</code>
    </example>
  </function>
  <function name="substring" type="xs:string">
    <signature>
      <arg name="sourceString" type="xs:string?"/>
      <arg name="start" type="xs:double"/>
    </signature>
    <signature>
      <arg name="sourceString" type="xs:string?"/>
      <arg name="start" type="xs:double"/>
      <arg name="length" type="xs:double"/>
    </signature>
    <summary>Returns the portion of the value of <code>$sourceString</code>
beginning at the position indicated by the value of
<code>$start</code> and continuing for the number of characters
indicated by the value of <code>$length</code>.</summary>
    <rule>If the value of <code>$sourceString</code> is the empty
sequence, the function returns the zero-length string.</rule>
    <rule>Otherwise, the function returns a string comprising those
characters of <code>$sourceString</code> whose index position
(counting from one) is greater than or equal to the value of
<code>$start</code> (rounded to an integer), and (if
<code>$length</code> is specified) less than the sum of
<code>$start</code> and <code>$length</code> (both rounded to
integers).</rule>
    <rule>The characters returned do not extend beyond
<code>$sourceString</code>. If <code>$start</code> is zero or
negative, only those characters in positions greater than zero are
returned.</rule>
    <rule>More specifically, the three argument version of the function
returns the characters in <code>$sourceString</code> whose position
<code>$p</code> satisfies:</rule>
    <rule>
      <a href="#func-round">
        <code>fn:round($start) &lt;= $p &lt;
fn:round($start) + fn:round($length)</code>
      </a>
    </rule>
    <rule>The two argument version of the function assumes that
<code>$length</code> is infinite and thus returns the characters in
<code>$sourceString</code> whose position <code>$p</code>
satisfies:</rule>
    <rule>
      <a href="#func-round">
        <code>fn:round($start) &lt;=
$p</code>
      </a>
    </rule>
    <rule>In the above computations, the rules for <a href="#func-numeric-less-than">
        <code>op:numeric-less-than</code>
      </a> and
<a href="#func-numeric-greater-than">
        <code>op:numeric-greater-than</code>
      </a>
apply.</rule>
    <example>The expression <code>fn:substring("motor car", 6)</code> returns
<code>" car"</code>. <em>(Characters starting at position 6 to the
end of <code>$sourceString</code> are selected.).</em>
    </example>
    <example>The expression <code>fn:substring("metadata", 4, 3)</code>
returns <code>"ada"</code>. <em>(Characters at positions greater
than or equal to 4 and less than 7 are selected.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", 1.5, 2.6)</code>
returns <code>"234"</code>. <em>(Characters at positions greater
than or equal to 2 and less than 5 are selected.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", 0, 3)</code> returns
<code>"12"</code>. <em>(Characters at positions greater than or
equal to 0 and less than 3 are selected. Since the first position
is 1, these are the characters at positions 1 and 2.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", 5, -3)</code> returns
<code>""</code>. <em>(Characters at positions greater than or equal
to 5 and less than 2 are selected.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", -3, 5)</code> returns
<code>"1"</code>. <em>(Characters at positions greater than or
equal to -3 and less than 2 are selected. Since the first position
is 1, this is the character at position 1.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", 0 div 0E0, 3)</code>
returns <code>""</code>. <em>(Since <code>0 div 0E0</code> returns
<code>NaN</code>, and <code>NaN</code> compared to any other number
returns <code>false</code>, no characters are selected.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", 1, 0 div 0E0)</code>
returns <code>""</code>. <em>(As above.).</em>
    </example>
    <example>The expression <code>fn:substring((), 1, 3)</code> returns
<code>""</code>.</example>
    <example>The expression <code>fn:substring("12345", -42, 1 div
0E0)</code> returns <code>"12345"</code>. <em>(Characters at
positions greater than or equal to -42 and less than INF are
selected.).</em>
    </example>
    <example>The expression <code>fn:substring("12345", -1 div 0E0, 1 div
0E0)</code> returns <code>""</code>. <em>(Since the value of
<code>-INF + INF</code> is <code>NaN</code>, no characters are
selected.).</em>
    </example>
  </function>
  <function name="string-length" type="xs:integer">
    <signature/>
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Returns the number of characters in a string.</summary>
    <rule>The function returns an <code>xs:integer</code> equal to the
length in characters of the value of <code>$arg</code>.</rule>
    <rule>Calling the zero-argument version of the function is equivalent
to calling <code>fn:string-length(fn:string(.))</code>.</rule>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
function returns the <code>xs:integer</code> value zero (0).</rule>
    <example>The expression <code>fn:string-length("Harp not on that string,
madam; that is past.")</code> returns <code>45</code>.</example>
    <example>The expression <code>fn:string-length(())</code> returns
<code>0</code>.</example>
  </function>
  <function name="normalize-space" type="xs:string">
    <signature/>
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Returns the value of <code>$arg</code> with leading and trailing
whitespace removed, and sequences of internal whitespace reduced to
a single space character.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
function returns the zero-length string.</rule>
    <rule>The function returns a string constructed by stripping leading
and trailing whitespace from the value of <code>$arg</code>, and
replacing sequences of one or more adjacent whitespace characters
with a single space, <code>#x20</code>.</rule>
    <rule>The whitespace characters are defined in the metasymbol S
(Production 3) of <a href="#REC-xml">[REC-xml]</a>.</rule>
    <rule>If no argument is supplied, then <code>$arg</code> defaults to
the string value (calculated using <a href="#func-string">
        <code>fn:string</code>
      </a>) of the context item
(<code>.</code>).</rule>
    <example>The expression
<code>fn:normalize-space(" The    wealthy curled darlings
                                        of    our    nation. ")</code>
returns <code>"The wealthy curled darlings of our
nation."</code>.</example>
    <example>The expression <code>fn:normalize-space(())</code> returns
<code>""</code>.</example>
  </function>
  <function name="normalize-unicode" type="xs:string">
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:string?"/>
      <arg name="normalizationForm" type="xs:string"/>
    </signature>
    <summary>Returns the value of <code>$arg</code> after applying Unicode
normalization.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
function returns the zero-length string.</rule>
    <rule>If the single-argument version of the function is used, the
result is the same as calling the two-argument version with
<code>$normalizationForm</code> set to the string "NFC".</rule>
    <rule>Otherwise, the function returns the value of <code>$arg</code>
normalized according to the rules of the normalization form
identified by the value of <code>$normalizationForm</code>.</rule>
    <rule>The effective value of <code>$normalizationForm</code> is the
value of the expression <a href="#func-upper-case">
        <code>fn:upper-case(fn:normalize-space($normalizationForm))</code>
      </a>.</rule>
    <rule>See <a href="#charmod-normalization">[Character Model for the
World Wide Web 1.0: Normalization]</a> for a description of the
normalization forms.</rule>
    <rule>Conforming implementations <a title="must" class="termref" href="#must">
        <span class="arrow">·</span>must<span class="arrow">·</span>
      </a> support normalization form "NFC" and <a title="may" class="termref" href="#may">
        <span class="arrow">·</span>may<span class="arrow">·</span>
      </a> support
normalization forms "NFD", "NFKC", "NFKD", and "FULLY-NORMALIZED".
They <a title="may" class="termref" href="#may">
        <span class="arrow">·</span>may<span class="arrow">·</span>
      </a> also support
other normalization forms with <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a> semantics.</rule>
  </function>
  <function name="upper-case" type="xs:string">
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Converts a string to upper case.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
zero-length string is returned.</rule>
    <rule>Otherwise, the function returns the value of <code>$arg</code>
after translating every character to its upper-case correspondent
as defined in the appropriate case mappings section in the Unicode
standard <a href="#Unicode4">[The Unicode Standard]</a>. For
versions of Unicode beginning with the 2.1.8 update, only
locale-insensitive case mappings should be applied. Beginning with
version 3.2.0 (and likely future versions) of Unicode, precise
mappings are described in default case operations, which are full
case mappings in the absence of tailoring for particular languages
and environments. Every lower-case character that does not have an
upper-case correspondent, as well as every upper-case character, is
included in the returned value in its original form.</rule>
    <example>The expression <code>fn:upper-case("abCd0")</code> returns
<code>"ABCD0"</code>.</example>
  </function>
  <function name="lower-case" type="xs:string">
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Converts a string to lower case.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
zero-length string is returned.</rule>
    <rule>Otherwise, the function returns the value of <code>$arg</code>
after translating every character to its lower-case correspondent
as defined in the appropriate case mappings section in the Unicode
standard <a href="#Unicode4">[The Unicode Standard]</a>. For
versions of Unicode beginning with the 2.1.8 update, only
locale-insensitive case mappings should be applied. Beginning with
version 3.2.0 (and likely future versions) of Unicode, precise
mappings are described in default case operations, which are full
case mappings in the absence of tailoring for particular languages
and environments. Every upper-case character that does not have a
lower-case correspondent, as well as every lower-case character, is
included in the returned value in its original form.</rule>
    <example>The expression <code>fn:lower-case("ABc!D")</code> returns
<code>"abc!d"</code>.</example>
  </function>
  <function name="translate" type="xs:string">
    <signature>
      <arg name="arg" type="xs:string?"/>
      <arg name="mapString" type="xs:string"/>
      <arg name="transString" type="xs:string"/>
    </signature>
    <summary>Returns the value of <code>$arg</code> modified by replacing or
removing individual characters.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
function returns the zero-length string.</rule>
    <rule>Otherwise, the function returns a result string constructed by
processing each character in the value of <code>$arg</code>, in
order, according to the following rules:</rule>
    <example>The expression <code>fn:translate("bar","abc","ABC")</code>
returns <code>"BAr"</code>.</example>
    <example>The expression <code>fn:translate("--aaa--","abc-","ABC")</code>
returns <code>"AAA"</code>.</example>
    <example>The expression <code>fn:translate("abcdabc", "abc", "AB")</code>
returns <code>"ABdAB"</code>.</example>
  </function>
  <function name="contains" type="xs:boolean">
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns true if the string <code>$arg1</code> contains
<code>$arg2</code> as a substring, taking collations into
account.</summary>
    <rule>If the value of <code>$arg1</code> or <code>$arg2</code> is the
empty sequence, or contains only ignorable collation units, it is
interpreted as the zero-length string.</rule>
    <rule>If the value of <code>$arg2</code> is the zero-length string,
then the function returns <code>true</code>.</rule>
    <rule>If the value of <code>$arg1</code> is the zero-length string,
the function returns <code>false</code>.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns an <code>xs:boolean</code> indicating
whether or not the value of <code>$arg1</code> contains (at the
beginning, at the end, or anywhere within) at least one sequence of
collation units that provides a <b>minimal match</b> to the
collation units in the value of <code>$arg2</code>, according to
the collation that is used.</rule>
    <example>The collation used in these examples,
<code>http://example.com/CollationA</code> is a collation in which
both "-" and "*" are ignorable collation units.</example>
    <example>"Ignorable collation unit" is equivalent to "ignorable collation
element" in <a href="#Unicode-Collations">[Unicode Collation
Algorithm]</a>.</example>
    <example>The expression <code>fn:contains ( "tattoo", "t")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:contains ( "tattoo", "ttt")</code>
returns <code>false()</code>.</example>
    <example>The expression <code>fn:contains ( "", ())</code> returns
<code>true()</code>. <em>(The first rule is applied, followed by
the second rule.).</em>
    </example>
    <example>The expression <code>fn:contains ( "abcdefghi", "-d-e-f-",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:contains ( "a*b*c*d*e*f*g*h*i*",
"d-ef-", "http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:contains ( "abcd***e---f*--*ghi", "def",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:contains ( (), "--***-*---",
"http://example.com/CollationA")</code> returns
<code>true()</code>. <em>(The second argument contains only
ignorable collation units and is equivalent to the zero-length
string.).</em>
    </example>
  </function>
  <function name="starts-with" type="xs:boolean">
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns true if the string <code>$arg1</code> contains
<code>$arg2</code> as a leading substring, taking collations into
account.</summary>
    <rule>If the value of <code>$arg1</code> or <code>$arg2</code> is the
empty sequence, or contains only ignorable collation units, it is
interpreted as the zero-length string.</rule>
    <rule>If the value of <code>$arg2</code> is the zero-length string,
then the function returns <code>true</code>. If the value of
<code>$arg1</code> is the zero-length string and the value of
<code>$arg2</code> is not the zero-length string, then the function
returns <code>false</code>.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns an <code>xs:boolean</code> indicating
whether or not the value of <code>$arg1</code> starts with a
sequence of collation units that provides a <b>match</b> to the
collation units of <code>$arg2</code> according to the collation
that is used.</rule>
    <example>The collation used in these examples,
<code>http://example.com/CollationA</code> is a collation in which
both "-" and "*" are ignorable collation units.</example>
    <example>"Ignorable collation unit" is equivalent to "ignorable collation
element" in <a href="#Unicode-Collations">[Unicode Collation
Algorithm]</a>.</example>
    <example>The expression <code>fn:starts-with("tattoo", "tat")</code>
returns <code>true()</code>.</example>
    <example>The expression <code>fn:starts-with ( "tattoo", "att")</code>
returns <code>false()</code>.</example>
    <example>The expression <code>fn:starts-with ((), ())</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:starts-with ( "abcdefghi", "-a-b-c-",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:starts-with ( "a*b*c*d*e*f*g*h*i*",
"a-bc-", "http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:starts-with ( "abcd***e---f*--*ghi",
"abcdef", "http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:starts-with ( (), "--***-*---",
"http://example.com/CollationA")</code> returns
<code>true()</code>. <em>(The second argument contains only
ignorable collation units and is equivalent to the zero-length
string.).</em>
    </example>
    <example>The expression <code>fn:starts-with ( "-abcdefghi", "-abc",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
  </function>
  <function name="ends-with" type="xs:boolean">
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns true if the string <code>$arg1</code> contains
<code>$arg2</code> as a trailing substring, taking collations into
account.</summary>
    <rule>If the value of <code>$arg1</code> or <code>$arg2</code> is the
empty sequence, or contains only ignorable collation units, it is
interpreted as the zero-length string.</rule>
    <rule>If the value of <code>$arg2</code> is the zero-length string,
then the function returns <code>true</code>. If the value of
<code>$arg1</code> is the zero-length string and the value of
<code>$arg2</code> is not the zero-length string, then the function
returns <code>false</code>.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns an <code>xs:boolean</code> indicating
whether or not the value of <code>$arg1</code> starts with a
sequence of collation units that provides a <b>match</b> to the
collation units of <code>$arg2</code> according to the collation
that is used.</rule>
    <example>The collation used in these examples,
<code>http://example.com/CollationA</code> is a collation in which
both "-" and "*" are ignorable collation units.</example>
    <example>"Ignorable collation unit" is equivalent to "ignorable collation
element" in <a href="#Unicode-Collations">[Unicode Collation
Algorithm]</a>.</example>
    <example>The expression <code>fn:ends-with ( "tattoo", "tattoo")</code>
returns <code>true()</code>.</example>
    <example>The expression <code>fn:ends-with ( "tattoo", "atto")</code>
returns <code>false()</code>.</example>
    <example>The expression <code>fn:ends-with ((), ())</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:ends-with ( "abcdefghi", "-g-h-i-",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:ends-with ( "abcd***e---f*--*ghi",
"defghi", "http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:ends-with ( "abcd***e---f*--*ghi",
"defghi", "http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:ends-with ( (), "--***-*---",
"http://example.com/CollationA")</code> returns
<code>true()</code>. <em>(The second argument contains only
ignorable collation units and is equivalent to the zero-length
string.).</em>
    </example>
    <example>The expression <code>fn:ends-with ( "abcdefghi", "ghi-",
"http://example.com/CollationA")</code> returns
<code>true()</code>.</example>
  </function>
  <function name="substring-before" type="xs:string">
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns the part of <code>$arg1</code> that precedes the first
occurrence of <code>$arg2</code>, taking collations into
account.</summary>
    <rule>If the value of <code>$arg1</code> or <code>$arg2</code> is the
empty sequence, or contains only ignorable collation units, it is
interpreted as the zero-length string.</rule>
    <rule>If the value of <code>$arg2</code> is the zero-length string,
then the function returns the zero-length string.</rule>
    <rule>If the value of <code>$arg1</code> does not contain a string
that is equal to the value of <code>$arg2</code>, then the function
returns the zero-length string.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns the substring of the value of
<code>$arg1</code> that precedes in the value of <code>$arg1</code>
the first occurrence of a sequence of collation units that provides
a <b>minimal match</b> to the collation units of <code>$arg2</code>
according to the collation that is used.</rule>
    <example>The collation used in these examples,
<code>http://example.com/CollationA</code> is a collation in which
both "-" and "*" are ignorable collation units.</example>
    <example>"Ignorable collation unit" is equivalent to "ignorable collation
element" in <a href="#Unicode-Collations">[Unicode Collation
Algorithm]</a>.</example>
    <example>The expression <code>fn:substring-before ( "tattoo",
"attoo")</code> returns <code>"t"</code>.</example>
    <example>The expression <code>fn:substring-before ( "tattoo",
"tatto")</code> returns <code>""</code>.</example>
    <example>The expression <code>fn:substring-before ((), ())</code> returns
<code>""</code>.</example>
    <example>The expression <code>fn:substring-before ( "abcdefghi",
"--d-e-", "http://example.com/CollationA")</code> returns
<code>"abc"</code>.</example>
    <example>The expression <code>fn:substring-before ( "abc--d-e-fghi",
"--d-e-", "http://example.com/CollationA")</code> returns
<code>"abc--"</code>.</example>
    <example>The expression <code>fn:substring-before ( "a*b*c*d*e*f*g*h*i*",
"***cde", "http://example.com/CollationA")</code> returns
<code>"a*b*"</code>.</example>
    <example>The expression <code>fn:substring-before ( "Eureka!",
"--***-*---", "http://example.com/CollationA")</code> returns
<code>""</code>. <em>(The second argument contains only ignorable
collation units and is equivalent to the zero-length
string.).</em>
    </example>
  </function>
  <function name="substring-after" type="xs:string">
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="arg1" type="xs:string?"/>
      <arg name="arg2" type="xs:string?"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns the part of <code>$arg1</code> that follows the first
occurrence of <code>$arg2</code>, taking collations into
account.</summary>
    <rule>If the value of <code>$arg1</code> or <code>$arg2</code> is the
empty sequence, or contains only ignorable collation units, it is
interpreted as the zero-length string.</rule>
    <rule>If the value of <code>$arg2</code> is the zero-length string,
then the function returns the value of <code>$arg1</code>.</rule>
    <rule>If the value of <code>$arg1</code> does not contain a string
that is equal to the value of <code>$arg2</code>, then the function
returns the zero-length string.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns the substring of the value of
<code>$arg1</code> that follows in the value of <code>$arg1</code>
the first occurrence of a sequence of collation units that provides
a <b>minimal match</b> to the collation units of <code>$arg2</code>
according to the collation that is used.</rule>
    <example>The collation used in these examples,
<code>http://example.com/CollationA</code> is a collation in which
both "-" and "*" are ignorable collation units.</example>
    <example>"Ignorable collation unit" is equivalent to "ignorable collation
element" in <a href="#Unicode-Collations">[Unicode Collation
Algorithm]</a>.</example>
    <example>The expression <code>fn:substring-after("tattoo", "tat")</code>
returns <code>"too"</code>.</example>
    <example>The expression <code>fn:substring-after("tattoo",
"tattoo")</code> returns <code>""</code>.</example>
    <example>The expression <code>fn:substring-after((), ())</code> returns
<code>""</code>.</example>
    <example>The expression <code>fn:substring-after("abcdefghi", "--d-e-",
"http://example.com/CollationA")</code> returns
<code>"fghi"</code>.</example>
    <example>The expression <code>fn:substring-after("abc--d-e-fghi",
"--d-e-", "http://example.com/CollationA")</code> returns
<code>"-fghi"</code>.</example>
    <example>The expression <code>fn:substring-after ( "a*b*c*d*e*f*g*h*i*",
"***cde***", "http://example.com/CollationA")</code> returns
<code>"*f*g*h*i*"</code>.</example>
    <example>The expression <code>fn:substring-after ( "Eureka!",
"--***-*---", "http://example.com/CollationA")</code> returns
<code>"Eureka!"</code>. <em>(The second argument contains only
ignorable collation units and is equivalent to the zero-length
string.).</em>
    </example>
  </function>
  <function name="matches" type="xs:boolean">
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
    </signature>
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
      <arg name="flags" type="xs:string"/>
    </signature>
    <summary>Returns true if the supplied string matches a given regular
expression.</summary>
    <rule>The effect of calling the first version of this function
(omitting the argument <code>$flags</code>) is the same as the
effect of calling the second version with the <code>$flags</code>
argument set to a zero-length string. Flags are defined in <a href="#flags">
        <b>5.6.1.1 Flags</b>
      </a>.</rule>
    <rule>If <code>$input</code> is the empty sequence, it is interpreted
as the zero-length string.</rule>
    <rule>The function returns <code>true</code> if <code>$input</code> or
some substring of <code>$input</code> matches the regular
expression supplied as <code>$pattern</code>. Otherwise, the
function returns <code>false</code>. The matching rules are
influenced by the value of <code>$flags</code> if present.</rule>
    <example>The expression <code>fn:matches("abracadabra", "bra")</code>
returns <code>true()</code>.</example>
    <example>The expression <code>fn:matches("abracadabra", "^a.*a$")</code>
returns <code>true()</code>.</example>
    <example>The expression <code>fn:matches("abracadabra", "^bra")</code>
returns <code>false()</code>.</example>
    <example>Given the source document:</example>
    <example>let <code>$poem</code> :=</example>
    <example>the following function calls produce the following results, with
the <code>poem</code> element as the context node:</example>
    <example>The expression <code>fn:matches($poem, "Kaum.*krähen")</code>
returns <code>false()</code>.</example>
    <example>The expression <code>fn:matches($poem, "Kaum.*krähen",
"s")</code> returns <code>true()</code>.</example>
    <example>The expression <code>fn:matches($poem, "^Kaum.*gesehen,$",
"m")</code> returns <code>true()</code>.</example>
    <example>The expression <code>fn:matches($poem,
"^Kaum.*gesehen,$")</code> returns <code>false()</code>.</example>
    <example>The expression <code>fn:matches($poem, "kiki", "i")</code>
returns <code>true()</code>.</example>
  </function>
  <function name="replace" type="xs:string">
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
      <arg name="replacement" type="xs:string"/>
    </signature>
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
      <arg name="replacement" type="xs:string"/>
      <arg name="flags" type="xs:string"/>
    </signature>
    <summary>Returns a string produced from the input string by replacing any
substrings that match a given regular expression with a supplied
replacement string.</summary>
    <rule>The effect of calling the first version of this function
(omitting the argument <code>$flags</code>) is the same as the
effect of calling the second version with the <code>$flags</code>
argument set to a zero-length string. Flags are defined in <a href="#flags">
        <b>5.6.1.1 Flags</b>
      </a>.</rule>
    <rule>The <code>$flags</code> argument is interpreted in the same
manner as for the <a href="#func-matches">
        <code>fn:matches</code>
      </a> function.</rule>
    <rule>If <code>$input</code> is the empty sequence, it is interpreted
as the zero-length string.</rule>
    <rule>The function returns the <code>xs:string</code> that is obtained
by replacing each non-overlapping substring of <code>$input</code>
that matches the given <code>$pattern</code> with an occurrence of
the <code>$replacement</code> string.</rule>
    <rule>If two overlapping substrings of <code>$input</code> both match
the <code>$pattern</code>, then only the first one (that is, the
one whose first character comes first in the <code>$input</code>
string) is replaced.</rule>
    <rule>If the <code>q</code> flag is present, the replacement string is
used <em>as is</em>.</rule>
    <rule>
      <span>Otherwise,</span> within the <code>$replacement</code>
string, a variable <code>$N</code> may be used to refer to the
substring captured by the Nth parenthesized sub-expression in the
regular expression. For each match of the pattern, these variables
are assigned the value of the content matched by the relevant
sub-expression, and the modified replacement string is then
substituted for the characters in <code>$input</code> that matched
the pattern. <code>$0</code> refers to the substring captured by
the regular expression as a whole.</rule>
    <rule>More specifically, the rules are as follows, where
<code>S</code> is the number of parenthesized sub-expressions in
the regular expression, and <code>N</code> is the decimal number
formed by taking all the digits that consecutively follow the
<code>$</code> character:</rule>
    <rule>For example, if the replacement string is " <code>$23</code> "
and there are 5 substrings, the result contains the value of the
substring that matches the second sub-expression, followed by the
digit " <code>3</code> ".</rule>
    <rule>Unless the <code>q</code> flag is used, a literal <code>$</code>
character within the replacement string must be written as
<code>\$</code>, and a literal <code>\</code> character must be
written as <code>\\</code>.</rule>
    <rule>If two alternatives within the pattern both match at the same
position in the <code>$input</code>, then the match that is chosen
is the one matched by the first alternative. For example:</rule>
    <example>The expression <code>replace("abracadabra", "bra", "*")</code>
returns <code>"a*cada*"</code>.</example>
    <example>The expression <code>replace("abracadabra", "a.*a", "*")</code>
returns <code>"*"</code>.</example>
    <example>The expression <code>replace("abracadabra", "a.*?a", "*")</code>
returns <code>"*c*bra"</code>.</example>
    <example>The expression <code>replace("abracadabra", "a", "")</code>
returns <code>"brcdbr"</code>.</example>
    <example>The expression <code>replace("abracadabra", "a(.)",
"a$1$1")</code> returns <code>"abbraccaddabbra"</code>.</example>
    <example>The expression <code>replace("abracadabra", ".*?", "$1")</code>
raises an error, because the pattern matches the zero-length
string</example>
    <example>The expression <code>replace("AAAA", "A+", "b")</code> returns
<code>"b"</code>.</example>
    <example>The expression <code>replace("AAAA", "A+?", "b")</code> returns
<code>"bbbb"</code>.</example>
    <example>The expression <code>replace("darted", "^(.*?)d(.*)$",
"$1c$2")</code> returns <code>"carted"</code>. <em>(The first
<code>d</code> is replaced.).</em>
    </example>
  </function>
  <function name="tokenize" type="xs:string*">
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
    </signature>
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
      <arg name="flags" type="xs:string"/>
    </signature>
    <summary>Returns a sequence of strings constructed by splitting the input
wherever a separator is found; the separator is any substring that
matches a given regular expression.</summary>
    <rule>The effect of calling the first version of this function
(omitting the argument <code>$flags</code>) is the same as the
effect of calling the second version with the <code>$flags</code>
argument set to a zero-length string. Flags are defined in <a href="#flags">
        <b>5.6.1.1 Flags</b>
      </a>.</rule>
    <rule>The <code>$flags</code> argument is interpreted in the same way
as for the <a href="#func-matches">
        <code>fn:matches</code>
      </a>
function.</rule>
    <rule>If <code>$input</code> is the empty sequence, or if
<code>$input</code> is the zero-length string, the function returns
the empty sequence.</rule>
    <rule>The function returns a sequence of strings formed by breaking
the <code>$input</code> string into a sequence of strings, treating
any substring that matches <code>$pattern</code> as a separator.
The separators themselves are not returned.</rule>
    <rule>If a separator occurs at the start of the <code>$input</code>
string, the result sequence will start with a zero-length string.
Zero-length strings will also occur in the result sequence if a
separator occurs at the end of the <code>$input</code> string, or
if two adjacent substrings match the supplied
<code>$pattern</code>.</rule>
    <rule>If two alternatives within the supplied <code>$pattern</code>
both match at the same position in the <code>$input</code> string,
then the match that is chosen is the first. For example:</rule>
    <example>The expression <code>fn:tokenize("The cat sat on the mat",
"\s+")</code> returns <code>("The", "cat", "sat", "on", "the",
"mat")</code>.</example>
    <example>The expression <code>fn:tokenize("1, 15, 24, 50", ",\s*")</code>
returns <code>("1", "15", "24", "50")</code>.</example>
    <example>The expression <code>fn:tokenize("1,15,,24,50,", ",")</code>
returns <code>("1", "15", "", "24", "50", "")</code>.</example>
    <example>
      <code>fn:tokenize("abba", ".?")</code> raises the error
[<a href="#ERRFORX0003" title="err:FORX0003">err:FORX0003</a>].</example>
    <example>The expression <code>fn:tokenize("Some unparsed &lt;br&gt; HTML
&lt;BR&gt; text", "\s*&lt;br&gt;\s*", "i")</code> returns
<code>("Some unparsed", "HTML", "text")</code>.</example>
  </function>
  <function name="analyze-string" type="element(fn:analyze-string-result)">
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
    </signature>
    <signature>
      <arg name="input" type="xs:string?"/>
      <arg name="pattern" type="xs:string"/>
      <arg name="flags" type="xs:string"/>
    </signature>
    <summary>Analyzes a string using a regular expression, returning an XML
structure that identifies which parts of the input string matched
or failed to match the regular expression, and in the case of
matched substrings, which substrings matched each capturing group
in the regular expression.</summary>
    <rule>The effect of calling the first version of this function
(omitting the argument <code>$flags</code>) is the same as the
effect of calling the second version with the <code>$flags</code>
argument set to a zero-length string. Flags are defined in <a href="#flags">
        <b>5.6.1.1 Flags</b>
      </a>.</rule>
    <rule>The <code>$flags</code> argument is interpreted in the same way
as for the <a href="#func-matches">
        <code>fn:matches</code>
      </a>
function.</rule>
    <rule>If <code>$input</code> is the empty sequence the function
behaves as if <code>$input</code> were the zero-length string. In
this situation the result will be an element node with no
children.</rule>
    <rule>The function returns an element node whose local name is
<code>analyze-string-result</code>. This element and all its
descendant elements have the namespace URI
<code>http://www.w3.org/2005/xpath-functions</code>. The namespace
prefix is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>. The children of this element are a sequence
of <code>fn:match</code> and <code>fn:non-match</code> elements.
This sequence is formed by breaking the <code>$input</code> string
into a sequence of strings, returning any substring that matches
<code>$pattern</code> as the content of a <code>match</code>
element, and any intervening substring as the content of a
<code>non-match</code> element.</rule>
    <rule>More specifically, the function starts at the beginning of the
input string and attempts to find the first substring that matches
the regular expression. If there are several matches, the first
match is defined to be the one whose starting position comes first
in the string. If several alternatives within the regular
expression both match at the same position in the input string,
then the match that is chosen is the first alternative that
matches. For example, if the input string is <code>The quick brown
fox jumps</code> and the regular expression is
<code>jump|jumps</code>, then the match that is chosen is
<code>jump</code>.</rule>
    <rule>Having found the first match, the instruction proceeds to find
the second and subsequent matches by repeating the search, starting
at the first character that was not included in the previous
match.</rule>
    <rule>The input string is thus partitioned into a sequence of
substrings, some of which match the regular expression, others
which do not match it. Each substring will contain at least one
character. This sequence is represented in the result by the
sequence of <code>fn:match</code> and <code>fn:non-match</code>
children of the returned element node; the string value of the
<code>fn:match</code> or <code>fn:non-match</code> element will be
the corresponding substring of <code>$input</code>, and the string
value of the returned element node will therefore be the same as
<code>$input</code>.</rule>
    <rule>The content of an <code>fn:non-match</code> element is always a
single text node.</rule>
    <rule>The content of a <code>fn:match</code> element, however, is in
general a sequence of text nodes and <code>fn:group</code> element
children. An <code>fn:group</code> element with a <code>nr</code>
attribute having the integer value <var>N</var> identifies the
substring captured by the <var>Nth</var> parenthesized
sub-expression in the regular expression. For each capturing
subexpression there will be at most one corresponding
<code>fn:group</code> element in each <code>fn:match</code> element
in the result.</rule>
    <rule>If the function is called twice with the same arguments, it is
<a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a> whether the two calls return the same element
node or distinct (but deep equal) element nodes.</rule>
    <rule>A schema is defined for the structure of the returned element,
containing the definitions below. The returned element and its
descendants will have type annotations obtained by validating the
returned element against this schema, unless the function is used
in an environment where type annotations are not supported (for
example, a Basic XSLT Processor), in which case the elements will
all be annotated as <code>xs:untyped</code> and the attributes as
<code>xs:untypedAtomic</code>.</rule>
    <example>In the following examples, the result document is shown in
serialized form, with whitespace between the element nodes. This
whitespace is not actually present in the result.</example>
    <example>The expression <code>fn:analyze-string("The cat sat on the
mat.", "\w+")</code> returns <code>&lt;analyze-string-result
xmlns="http://www.w3.org/2005/xpath-functions"&gt;
&lt;match&gt;The&lt;/match&gt; &lt;non-match&gt; &lt;/non-match&gt;
&lt;match&gt;cat&lt;/match&gt; &lt;non-match&gt; &lt;/non-match&gt;
&lt;match&gt;sat&lt;/match&gt; &lt;non-match&gt; &lt;/non-match&gt;
&lt;match&gt;on&lt;/match&gt; &lt;non-match&gt; &lt;/non-match&gt;
&lt;match&gt;the&lt;/match&gt; &lt;non-match&gt; &lt;/non-match&gt;
&lt;match&gt;mat&lt;/match&gt; &lt;non-match&gt;.&lt;/non-match&gt;
&lt;/analyze-string-result&gt;</code>.</example>
    <example>The expression <code>fn:analyze-string("2008-12-03",
"^(\d+)\-(\d+)\-(\d+)$")</code> returns
<code>&lt;analyze-string-result
xmlns="http://www.w3.org/2005/xpath-functions"&gt;
&lt;match&gt;&lt;group nr="1"&gt;2008&lt;/group&gt;-&lt;group
nr="2"&gt;12&lt;/group&gt;-&lt;group
nr="3"&gt;03&lt;/group&gt;&lt;/match&gt;
&lt;/analyze-string-result&gt;</code>.</example>
    <example>The expression <code>fn:analyze-string("A1,C15,,D24, X50,",
"([A-Z])([0-9]+)")</code> returns <code>&lt;analyze-string-result
xmlns="http://www.w3.org/2005/xpath-functions"&gt;
&lt;match&gt;&lt;group nr="1"&gt;A&lt;/group&gt;&lt;group
nr="2"&gt;1&lt;/group&gt;&lt;/match&gt;
&lt;non-match&gt;,&lt;/non-match&gt; &lt;match&gt;&lt;group
nr="1"&gt;C&lt;/group&gt;&lt;group
nr="2"&gt;15&lt;/group&gt;&lt;/match&gt;
&lt;non-match&gt;,,&lt;/non-match&gt; &lt;match&gt;&lt;group
nr="1"&gt;D&lt;/group&gt;&lt;group
nr="2"&gt;24&lt;/group&gt;&lt;/match&gt; &lt;non-match&gt;,
&lt;/non-match&gt; &lt;match&gt;&lt;group
nr="1"&gt;X&lt;/group&gt;&lt;group
nr="2"&gt;50&lt;/group&gt;&lt;/match&gt;
&lt;non-match&gt;,&lt;/non-match&gt;
&lt;/analyze-string-result&gt;</code>.</example>
  </function>
  <function name="resolve-uri" type="xs:anyURI?">
    <signature>
      <arg name="relative" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="relative" type="xs:string?"/>
      <arg name="base" type="xs:string"/>
    </signature>
    <summary>Resolves a relative URI reference against an absolute URI.</summary>
    <rule>If <code>$relative</code> is the empty sequence, the function
returns the empty sequence.</rule>
    <rule>The first form of this function resolves <code>$relative</code>
against the value of the base-uri property from the static
context.</rule>
    <rule>If <code>$relative</code> is a relative URI reference, it is
resolved against <code>$base</code>, or against the base-uri
property from the static context, using an algorithm such as those
described in <a href="#rfc2396">[RFC 2396]</a> or <a href="#rfc3986">[RFC 3986]</a>, and the resulting absolute URI reference
is returned.</rule>
    <rule>If <code>$relative</code> is an absolute URI reference, it is
returned unchanged.</rule>
  </function>
  <function name="encode-for-uri" type="xs:string">
    <signature>
      <arg name="uri-part" type="xs:string?"/>
    </signature>
    <summary>Encodes reserved characters in a string that is intended to be
used in the path segment of a URI.</summary>
    <rule>If <code>$uri-part</code> is the empty sequence, the function
returns the zero-length string.</rule>
    <rule>This function applies the URI escaping rules defined in section
2 of <a href="#rfc3986">[RFC 3986]</a> to the
<code>xs:string</code> supplied as <code>$uri-part</code>. The
effect of the function is to escape reserved characters. Each such
character in the string is replaced with its percent-encoded form
as described in <a href="#rfc3986">[RFC 3986]</a>.</rule>
    <rule>Since <a href="#rfc3986">[RFC 3986]</a> recommends that, for
consistency, URI producers and normalizers should use uppercase
hexadecimal digits for all percent-encodings, this function must
always generate hexadecimal values using the upper-case letters
A-F.</rule>
    <example>The expression
<code>fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</code>
returns
<code>"http%3A%2F%2Fwww.example.com%2F00%2FWeather%2FCA%2FLos%2520Angeles%23ocean"</code>.
<em>(This is probably not what the user intended because all of the
delimiters have been encoded.).</em>
    </example>
    <example>The expression <code>concat("http://www.example.com/",
encode-for-uri("~bébé"))</code> returns
<code>"http://www.example.com/~b%C3%A9b%C3%A9"</code>.</example>
    <example>The expression <code>concat("http://www.example.com/",
encode-for-uri("100% organic"))</code> returns
<code>"http://www.example.com/100%25%20organic"</code>.</example>
  </function>
  <function name="iri-to-uri" type="xs:string">
    <signature>
      <arg name="iri" type="xs:string?"/>
    </signature>
    <summary>Converts a string containing an IRI into a URI according to the
rules of <a href="#rfc3987">[RFC 3987]</a>.</summary>
    <rule>If <code>$iri</code> is the empty sequence, the function returns
the zero-length string.</rule>
    <rule>Otherwise, the function converts the value of <code>$iri</code>
into a URI according to the rules given in Section 3.1 of <a href="#rfc3987">[RFC 3987]</a> by percent-encoding characters that are
allowed in an IRI but not in a URI. If <code>$iri</code> contains a
character that is invalid in an IRI, such as the space character
(see note below), the invalid character is replaced by its
percent-encoded form as described in <a href="#rfc3986">[RFC
3986]</a> before the conversion is performed.</rule>
    <rule>Since <a href="#rfc3986">[RFC 3986]</a> recommends that, for
consistency, URI producers and normalizers should use uppercase
hexadecimal digits for all percent-encodings, this function must
always generate hexadecimal values using the upper-case letters
A-F.</rule>
    <example>The expression <code>fn:iri-to-uri
("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</code>
returns
<code>"http://www.example.com/00/Weather/CA/Los%20Angeles#ocean"</code>.</example>
    <example>The expression <code>fn:iri-to-uri
("http://www.example.com/~bébé")</code> returns
<code>"http://www.example.com/~b%C3%A9b%C3%A9"</code>.</example>
  </function>
  <function name="escape-html-uri" type="xs:string">
    <signature>
      <arg name="uri" type="xs:string?"/>
    </signature>
    <summary>Escapes a URI in the same way that HTML user agents handle
attribute values expected to contain URIs.</summary>
    <rule>If <code>$uri</code> is the empty sequence, the function returns
the zero-length string.</rule>
    <rule>Otherwise, the function escapes all characters except printable
characters of the US-ASCII coded character set, specifically the
codepoints between 32 and 126 (decimal) inclusive. Each character
in <code>$uri</code> to be escaped is replaced by an escape
sequence, which is formed by encoding the character as a sequence
of octets in UTF-8, and then representing each of these octets in
the form %HH, where HH is the hexadecimal representation of the
octet. This function must always generate hexadecimal values using
the upper-case letters A-F.</rule>
    <example>The expression <code>fn:escape-html-uri
("http://www.example.com/00/Weather/CA/Los Angeles#ocean")</code>
returns <code>"http://www.example.com/00/Weather/CA/Los
Angeles#ocean"</code>.</example>
    <example>The expression <code>fn:escape-html-uri ("javascript:if
(navigator.browserLanguage == 'fr')
window.open('http://www.example.com/~bébé');")</code> returns
<code>"javascript:if (navigator.browserLanguage == 'fr')
window.open('http://www.example.com/~b%C3%A9b%C3%A9');"</code>.</example>
  </function>
  <function name="true" type="xs:boolean">
    <signature/>
    <summary>Returns the <code>xs:boolean</code> value <code>true</code>.</summary>
    <rule>The result is equivalent to <code>xs:boolean("1")</code>.</rule>
    <example>The expression <code>fn:true()</code> returns
<code>xs:boolean(1)</code>.</example>
  </function>
  <function name="false" type="xs:boolean">
    <signature/>
    <summary>Returns the <code>xs:boolean</code> value
<code>false</code>.</summary>
    <rule>The result is equivalent to <code>xs:boolean("0")</code>.</rule>
    <example>The expression <code>fn:false()</code> returns
<code>xs:boolean(0)</code>.</example>
  </function>
  <function name="boolean" type="xs:boolean">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Computes the effective boolean value of the sequence
<code>$arg</code>.</summary>
    <rule>The function computes the effective boolean value of a sequence,
defined according to the following rules. See also <a href="http://www.w3.org/TR/xpath20/#id-ebv">Section 2.4.3 Effective
Boolean Value</a>
      <sup>
        <small>XP</small>
      </sup>.</rule>
    <rule>The static semantics of this function are described in <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section
7.2.4 The fn:boolean function</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$abc</code> := <code>("a", "b", "")</code>
    </example>
    <example>
      <code>fn:boolean($abc)</code> raises a type error [<a href="#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>].</example>
    <example>The expression <code>fn:boolean($abc[1])</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:boolean($abc[0])</code> returns
<code>false()</code>.</example>
    <example>The expression <code>fn:boolean($abc[3])</code> returns
<code>false()</code>.</example>
  </function>
  <function name="not" type="xs:boolean">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns <code>true</code> if the effective boolean value of
<code>$arg</code> is <code>false</code>, or <code>false</code> if
it is <code>true</code>.</summary>
    <rule>The value of <code>$arg</code> is first reduced to an effective
boolean value by applying the <a href="#func-boolean">
        <code>fn:boolean()</code>
      </a> function. The
function returns <code>true</code> if the effective boolean value
is <code>false</code>, or <code>false</code> if the effective
boolean value is <code>true</code>.</rule>
    <example>The expression <code>fn:not(fn:true())</code> returns
<code>false()</code>.</example>
    <example>The expression <code>fn:not("false")</code> returns
<code>false()</code>.</example>
  </function>
  <function name="years-from-duration" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of years in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the years component in the value of <code>$arg</code>.
The result is obtained by casting <code>$arg</code> to an
<code>xs:yearMonthDuration</code> (see <a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the years component as described
in <a href="#canonical-yearMonthDuration">
        <b>8.2.1.3 Canonical
representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))</code>
returns <code>21</code>.</example>
    <example>The expression
<code>fn:years-from-duration(xs:yearMonthDuration("-P15M"))</code>
returns <code>-1</code>.</example>
    <example>The expression
<code>fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))</code>
returns <code>0</code>.</example>
  </function>
  <function name="months-from-duration" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of months in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the months component in the value of
<code>$arg</code>. The result is obtained by casting
<code>$arg</code> to an <code>xs:yearMonthDuration</code> (see
<a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the months component as described
in <a href="#canonical-yearMonthDuration">
        <b>8.2.1.3 Canonical
representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))</code>
returns <code>3</code>.</example>
    <example>The expression
<code>fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))</code>
returns <code>-6</code>.</example>
    <example>The expression
<code>fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))</code>
returns <code>0</code>.</example>
  </function>
  <function name="days-from-duration" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of days in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the days component in the value of <code>$arg</code>.
The result is obtained by casting <code>$arg</code> to an
<code>xs:dayTimeDuration</code> (see <a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the days component as described
in <a href="#canonical-dayTimeDuration">
        <b>8.2.2.3 Canonical
representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
returns <code>3</code>.</example>
    <example>The expression
<code>fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))</code>
returns <code>5</code>.</example>
    <example>The expression
<code>fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))</code>
returns <code>0</code>.</example>
  </function>
  <function name="hours-from-duration" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of hours in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the hours component in the value of <code>$arg</code>.
The result is obtained by casting <code>$arg</code> to an
<code>xs:dayTimeDuration</code> (see <a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the hours component as described
in <a href="#canonical-dayTimeDuration">
        <b>8.2.2.3 Canonical
representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
returns <code>10</code>.</example>
    <example>The expression
<code>fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))</code>
returns <code>12</code>.</example>
    <example>The expression
<code>fn:hours-from-duration(xs:dayTimeDuration("PT123H"))</code>
returns <code>3</code>.</example>
    <example>The expression
<code>fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))</code>
returns <code>-10</code>.</example>
  </function>
  <function name="minutes-from-duration" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of minutes in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the minutes component in the value of
<code>$arg</code>. The result is obtained by casting
<code>$arg</code> to an <code>xs:dayTimeDuration</code> (see
<a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the minutes component as
described in <a href="#canonical-dayTimeDuration">
        <b>8.2.2.3
Canonical representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))</code>
returns <code>0</code>.</example>
    <example>The expression
<code>fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))</code>
returns <code>-30</code>.</example>
  </function>
  <function name="seconds-from-duration" type="xs:decimal?">
    <signature>
      <arg name="arg" type="xs:duration?"/>
    </signature>
    <summary>Returns the number of seconds in a duration.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:decimal</code>
representing the seconds component in the value of
<code>$arg</code>. The result is obtained by casting
<code>$arg</code> to an <code>xs:dayTimeDuration</code> (see
<a href="#casting-to-durations">
        <b>18.1.4 Casting to duration
types</b>
      </a>) and then computing the seconds component as
described in <a href="#canonical-dayTimeDuration">
        <b>8.2.2.3
Canonical representation</b>
      </a>.</rule>
    <rule>If <code>$arg</code> is a negative duration then the result will
be negative..</rule>
    <rule>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the
function returns 0.</rule>
    <example>The expression
<code>fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))</code>
returns <code>12.5</code>.</example>
    <example>The expression
<code>fn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))</code>
returns <code>-16.0</code>.</example>
  </function>
  <function name="dateTime" type="xs:dateTime?">
    <signature>
      <arg name="arg1" type="xs:date?"/>
      <arg name="arg2" type="xs:time?"/>
    </signature>
    <summary>Returns an <code>xs:dateTime</code> value created by combining
an <code>xs:date</code> and an <code>xs:time</code>.</summary>
    <rule>If either <code>$arg1</code> or <code>$arg2</code> is the empty
sequence the function returns the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:dateTime</code>
whose date component is equal to <code>$arg1</code> and whose time
component is equal to <code>$arg2</code>.</rule>
    <rule>The timezone of the result is computed as follows:</rule>
    <example>The expression <code>fn:dateTime(xs:date("1999-12-31"),
xs:time("12:00:00"))</code> returns
<code>xs:dateTime("1999-12-31T12:00:00")</code>.</example>
    <example>The expression <code>fn:dateTime(xs:date("1999-12-31"),
xs:time("24:00:00"))</code> returns
<code>xs:dateTime("1999-12-31T00:00:00")</code>. <em>(This is
because <code>"24:00:00"</code> is an alternate lexical form for
<code>"00:00:00"</code>).</em>
    </example>
  </function>
  <function name="year-from-dateTime" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the year component of an <code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the year component in the local value of
<code>$arg</code>. The result may be negative.</rule>
    <example>The expression
<code>fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>1999</code>.</example>
    <example>The expression
<code>fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))</code>
returns <code>1999</code>.</example>
    <example>The expression
<code>fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))</code>
returns <code>1999</code>.</example>
    <example>The expression
<code>fn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</code>
returns <code>2000</code>.</example>
  </function>
  <function name="month-from-dateTime" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the month component of an <code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 1 and 12, both inclusive, representing the month component
in the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>5</code>.</example>
    <example>The expression
<code>fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))</code>
returns <code>12</code>.</example>
    <example>The expression
<code>fn:month-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
xs:dayTimeDuration("PT0S")))</code> returns <code>1</code>.</example>
  </function>
  <function name="day-from-dateTime" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the day component of an <code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 1 and 31, both inclusive, representing the day component in
the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>31</code>.</example>
    <example>The expression
<code>fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))</code>
returns <code>31</code>.</example>
    <example>The expression
<code>fn:day-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
xs:dayTimeDuration("PT0S")))</code> returns <code>1</code>.</example>
  </function>
  <function name="hours-from-dateTime" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the hours component of an <code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 0 and 23, both inclusive, representing the hours component
in the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))</code>
returns <code>8</code>.</example>
    <example>The expression
<code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))</code>
returns <code>21</code>.</example>
    <example>The expression
<code>fn:hours-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T21:20:00-05:00"),
xs:dayTimeDuration("PT0S")))</code> returns <code>2</code>.</example>
    <example>The expression
<code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))</code>
returns <code>12</code>.</example>
    <example>The expression
<code>fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</code>
returns <code>0</code>.</example>
  </function>
  <function name="minutes-from-dateTime" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the minute component of an <code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code> value
between 0 and 59, both inclusive, representing the minute component
in the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>20</code>.</example>
    <example>The expression
<code>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))</code>
returns <code>30</code>.</example>
  </function>
  <function name="seconds-from-dateTime" type="xs:decimal?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the seconds component of an
<code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:decimal</code> value
greater than or equal to zero and less than 60, representing the
seconds and fractional seconds in the local value of
<code>$arg</code>.</rule>
    <example>The expression
<code>fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>0</code>.</example>
  </function>
  <function name="timezone-from-dateTime" type="xs:dayTimeDuration?">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <summary>Returns the timezone component of an
<code>xs:dateTime</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns the timezone component of
<code>$arg</code>, if any. If <code>$arg</code> has a timezone
component, then the result is an <code>xs:dayTimeDuration</code>
that indicates deviation from UTC; its value may range from +14:00
to -14:00 hours, both inclusive. If <code>$arg</code> has no
timezone component, the result is the empty sequence.</rule>
    <example>The expression
<code>fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</code>
returns <code>xs:dayTimeDuration("-PT5H")</code>.</example>
    <example>The expression
<code>fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))</code>
returns <code>xs:dayTimeDuration("PT0S")</code>.</example>
    <example>The expression
<code>fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))</code>
returns <code>()</code>.</example>
  </function>
  <function name="year-from-date" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:date?"/>
    </signature>
    <summary>Returns the year component of an <code>xs:date</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
representing the year in the local value of <code>$arg</code>. The
value may be negative.</rule>
    <example>The expression
<code>fn:year-from-date(xs:date("1999-05-31"))</code> returns
<code>1999</code>.</example>
    <example>The expression
<code>fn:year-from-date(xs:date("2000-01-01+05:00"))</code> returns
<code>2000</code>.</example>
  </function>
  <function name="month-from-date" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:date?"/>
    </signature>
    <summary>Returns the month component of an <code>xs:date</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 1 and 12, both inclusive, representing the month component
in the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:month-from-date(xs:date("1999-05-31-05:00"))</code>
returns <code>5</code>.</example>
    <example>The expression
<code>fn:month-from-date(xs:date("2000-01-01+05:00"))</code>
returns <code>1</code>.</example>
  </function>
  <function name="day-from-date" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:date?"/>
    </signature>
    <summary>Returns the day component of an <code>xs:date</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 1 and 31, both inclusive, representing the day component in
the localized value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:day-from-date(xs:date("1999-05-31-05:00"))</code> returns
<code>31</code>.</example>
    <example>The expression
<code>fn:day-from-date(xs:date("2000-01-01+05:00"))</code> returns
<code>1</code>.</example>
  </function>
  <function name="timezone-from-date" type="xs:dayTimeDuration?">
    <signature>
      <arg name="arg" type="xs:date?"/>
    </signature>
    <summary>Returns the timezone component of an <code>xs:date</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns the timezone component of
<code>$arg</code>, if any. If <code>$arg</code> has a timezone
component, then the result is an <code>xs:dayTimeDuration</code>
that indicates deviation from UTC; its value may range from +14:00
to -14:00 hours, both inclusive. If <code>$arg</code> has no
timezone component, the result is the empty sequence.</rule>
    <example>The expression
<code>fn:timezone-from-date(xs:date("1999-05-31-05:00"))</code>
returns <code>xs:dayTimeDuration("-PT5H")</code>.</example>
    <example>The expression
<code>fn:timezone-from-date(xs:date("2000-06-12Z"))</code> returns
<code>xs:dayTimeDuration("PT0S")</code>.</example>
  </function>
  <function name="hours-from-time" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:time?"/>
    </signature>
    <summary>Returns the hours component of an <code>xs:time</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code>
between 0 and 23, both inclusive, representing the value of the
hours component in the local value of <code>$arg</code>.</rule>
    <example>Assume that the dynamic context provides an implicit timezone
value of <code>-05:00</code>.</example>
    <example>The expression
<code>fn:hours-from-time(xs:time("11:23:00"))</code> returns
<code>11</code>.</example>
    <example>The expression
<code>fn:hours-from-time(xs:time("21:23:00"))</code> returns
<code>21</code>.</example>
    <example>The expression
<code>fn:hours-from-time(xs:time("01:23:00+05:00"))</code> returns
<code>1</code>.</example>
    <example>The expression
<code>fn:hours-from-time(fn:adjust-time-to-timezone(xs:time("01:23:00+05:00"),
xs:dayTimeDuration("PT0S")))</code> returns <code>20</code>.</example>
    <example>The expression
<code>fn:hours-from-time(xs:time("24:00:00"))</code> returns
<code>0</code>.</example>
  </function>
  <function name="minutes-from-time" type="xs:integer?">
    <signature>
      <arg name="arg" type="xs:time?"/>
    </signature>
    <summary>Returns the minutes component of an <code>xs:time</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:integer</code> value
between 0 and 59, both inclusive, representing the value of the
minutes component in the local value of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:minutes-from-time(xs:time("13:00:00Z"))</code> returns
<code>0</code>.</example>
  </function>
  <function name="seconds-from-time" type="xs:decimal?">
    <signature>
      <arg name="arg" type="xs:time?"/>
    </signature>
    <summary>Returns the seconds component of an <code>xs:time</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:decimal</code> value
greater than or equal to zero and less than 60, representing the
seconds and fractional seconds in the local value of
<code>$arg</code>.</rule>
    <example>The expression
<code>fn:seconds-from-time(xs:time("13:20:10.5"))</code> returns
<code>10.5</code>.</example>
  </function>
  <function name="timezone-from-time" type="xs:dayTimeDuration?">
    <signature>
      <arg name="arg" type="xs:time?"/>
    </signature>
    <summary>Returns the timezone component of an <code>xs:time</code>.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns the timezone component of
<code>$arg</code>, if any. If <code>$arg</code> has a timezone
component, then the result is an <code>xs:dayTimeDuration</code>
that indicates deviation from UTC; its value may range from +14:00
to -14:00 hours, both inclusive. If <code>$arg</code> has no
timezone component, the result is the empty sequence.</rule>
    <example>The expression
<code>fn:timezone-from-time(xs:time("13:20:00-05:00"))</code>
returns <code>xs:dayTimeDuration("-PT5H")</code>.</example>
    <example>The expression
<code>fn:timezone-from-time(xs:time("13:20:00"))</code> returns
<code>()</code>.</example>
  </function>
  <function name="adjust-dateTime-to-timezone" type="xs:dateTime">
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:dateTime?"/>
      <arg name="timezone" type="xs:dayTimeDuration?"/>
    </signature>
    <summary>Adjusts an <code>xs:dateTime</code> value to a specific
timezone, or to no timezone at all.</summary>
    <rule>If <code>$timezone</code> is not specified, then the effective
value of <code>$timezone</code> is the value of the implicit
timezone in the dynamic context.</rule>
    <rule>If <code>$arg</code> is the empty sequence, then the function
returns the empty sequence.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
<code>$arg</code>.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is not the empty sequence, then the result
is <code>$arg</code> with <code>$timezone</code> as the timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
the local value of <code>$arg</code> without its timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is not the empty sequence, then the result
is the <code>xs:dateTime</code> value that is equal to
<code>$arg</code> and that has a timezone component equal to
<code>$timezone</code>.</rule>
    <example>Assume the dynamic context provides an implicit timezone of
<code>-05:00 (-PT5H0M)</code>.</example>
    <example>let <code>$tz-10</code> :=
<code>xs:dayTimeDuration("-PT10H")</code>
    </example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'))</code>
returns <code>xs:dateTime('2002-03-07T10:00:00-05:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'))</code>
returns <code>xs:dateTime('2002-03-07T12:00:00-05:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
$tz-10)</code> returns
<code>xs:dateTime('2002-03-07T10:00:00-10:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
$tz-10)</code> returns
<code>xs:dateTime('2002-03-07T07:00:00-10:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
xs:dayTimeDuration("PT10H"))</code> returns
<code>xs:dateTime('2002-03-08T03:00:00+10:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T00:00:00+01:00'),
xs:dayTimeDuration("-PT8H"))</code> returns
<code>xs:dateTime('2002-03-06T15:00:00-08:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
())</code> returns
<code>xs:dateTime('2002-03-07T10:00:00')</code>.</example>
    <example>The expression
<code>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
())</code> returns
<code>xs:dateTime('2002-03-07T10:00:00')</code>.</example>
  </function>
  <function name="adjust-date-to-timezone" type="xs:date?">
    <signature>
      <arg name="arg" type="xs:date?"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:date?"/>
      <arg name="timezone" type="xs:dayTimeDuration?"/>
    </signature>
    <summary>Adjusts an <code>xs:date</code> value to a specific timezone, or
to no timezone at all; the result is the date in the target
timezone that contains the starting instant of the supplied
date.</summary>
    <rule>If <code>$timezone</code> is not specified, then the effective
value of <code>$timezone</code> is the value of the implicit
timezone in the dynamic context.</rule>
    <rule>If <code>$arg</code> is the empty sequence, then the function
returns the empty sequence.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
the value of <code>$arg</code>.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is not the empty sequence, then the result
is <code>$arg</code> with <code>$timezone</code> as the timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
the local value of <code>$arg</code> without its timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is not the empty sequence, then the function
returns the value of the expression:</rule>
    <example>Assume the dynamic context provides an implicit timezone of
<code>-05:00 (-PT5H0M)</code>.</example>
    <example>let <code>$tz-10</code> :=
<code>xs:dayTimeDuration("-PT10H")</code>
    </example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07"))</code>
returns <code>xs:date("2002-03-07-05:00")</code>.</example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))</code>
returns <code>xs:date("2002-03-07-05:00")</code>.
<em>(<code>$arg</code> is converted to
<code>xs:dateTime("2002-03-07T00:00:00-07:00")</code>. This is
adjusted to the implicit timezone, giving
<code>"2002-03-07T02:00:00-05:00"</code>. ).</em>
    </example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
$tz-10)</code> returns
<code>xs:date("2002-03-07-10:00")</code>.</example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
$tz-10)</code> returns <code>xs:date("2002-03-06-10:00")</code>.
<em>(<code>$arg</code> is converted to the <code>xs:dateTime
"2002-03-07T00:00:00-07:00"</code>. This is adjusted to the given
timezone, giving <code>"2002-03-06T21:00:00-10:00"</code>.
).</em>
    </example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07"), ())</code>
returns <code>xs:date("2002-03-07")</code>.</example>
    <example>The expression
<code>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
())</code> returns <code>xs:date("2002-03-07")</code>.</example>
  </function>
  <function name="adjust-time-to-timezone" type="xs:time?">
    <signature>
      <arg name="arg" type="xs:time?"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:time?"/>
      <arg name="timezone" type="xs:dayTimeDuration?"/>
    </signature>
    <summary>Adjusts an <code>xs:time</code> value to a specific timezone, or
to no timezone at all.</summary>
    <rule>If <code>$timezone</code> is not specified, then the effective
value of <code>$timezone</code> is the value of the implicit
timezone in the dynamic context.</rule>
    <rule>If <code>$arg</code> is the empty sequence, then the function
returns the empty sequence.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
<code>$arg</code>.</rule>
    <rule>If <code>$arg</code> does not have a timezone component and
<code>$timezone</code> is not the empty sequence, then the result
is <code>$arg</code> with <code>$timezone</code> as the timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is the empty sequence, then the result is
the localized value of <code>$arg</code> without its timezone
component.</rule>
    <rule>If <code>$arg</code> has a timezone component and
<code>$timezone</code> is not the empty sequence, then:</rule>
    <example>Assume the dynamic context provides an implicit timezone of
<code>-05:00 (-PT5H0M)</code>.</example>
    <example>let <code>$tz-10</code> :=
<code>xs:dayTimeDuration("-PT10H")</code>
    </example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00"))</code>
returns <code>xs:time("10:00:00-05:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))</code>
returns <code>xs:time("12:00:00-05:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00"),
$tz-10)</code> returns <code>xs:time("10:00:00-10:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
$tz-10)</code> returns <code>xs:time("07:00:00-10:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00"), ())</code>
returns <code>xs:time("10:00:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
())</code> returns <code>xs:time("10:00:00")</code>.</example>
    <example>The expression
<code>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
xs:dayTimeDuration("PT10H"))</code> returns
<code>xs:time("03:00:00+10:00")</code>.</example>
  </function>
  <function name="format-dateTime" type="xs:string?">
    <signature>
      <arg name="value" type="xs:dateTime?"/>
      <arg name="picture" type="xs:string"/>
      <arg name="language" type="xs:string?"/>
      <arg name="calendar" type="xs:string?"/>
      <arg name="country" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="value" type="xs:dateTime?"/>
      <arg name="picture" type="xs:string"/>
    </signature>
    <summary>Returns a string containing an <code>xs:dateTime</code> value
formatted for display.</summary>
    <rule>See <a href="#rules-for-datetime-formatting">
        <b>9.8.4 The
date/time formatting functions</b>
      </a>.</rule>
  </function>
  <function name="format-date" type="xs:string?">
    <signature>
      <arg name="value" type="xs:date?"/>
      <arg name="picture" type="xs:string"/>
      <arg name="language" type="xs:string?"/>
      <arg name="calendar" type="xs:string?"/>
      <arg name="country" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="value" type="xs:date?"/>
      <arg name="picture" type="xs:string"/>
    </signature>
    <summary>Returns a string containing an <code>xs:date</code> value
formatted for display.</summary>
    <rule>See <a href="#rules-for-datetime-formatting">
        <b>9.8.4 The
date/time formatting functions</b>
      </a>.</rule>
  </function>
  <function name="format-time" type="xs:string?">
    <signature>
      <arg name="value" type="xs:time?"/>
      <arg name="picture" type="xs:string"/>
      <arg name="language" type="xs:string?"/>
      <arg name="calendar" type="xs:string?"/>
      <arg name="country" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="value" type="xs:time?"/>
      <arg name="picture" type="xs:string"/>
    </signature>
    <summary>Returns a string containing an <code>xs:time</code> value
formatted for display.</summary>
    <rule>See <a href="#rules-for-datetime-formatting">
        <b>9.8.4 The
date/time formatting functions</b>
      </a>.</rule>
  </function>
  <function name="resolve-QName" type="xs:QName?">
    <signature>
      <arg name="qname" type="xs:string?"/>
      <arg name="element" type="element()"/>
    </signature>
    <summary>Returns an <code>xs:QName</code> value (that is, an
expanded-QName) by taking an <code>xs:string</code> that has the
lexical form of an <code>xs:QName</code> (a string in the form
"prefix:local-name" or "local-name") and resolving it using the
in-scope namespaces for a given element.</summary>
    <rule>If <code>$qname</code> is the empty sequence, returns the empty
sequence.</rule>
    <rule>More specifically, the function searches the namespace bindings
of <code>$element</code> for a binding whose name matches the
prefix of <code>$qname</code>, or the zero-length string if it has
no prefix, and constructs an expanded-QName whose local name is
taken from the supplied <code>$qname</code>, and whose namespace
URI is taken from the string value of the namespace binding.</rule>
    <rule>If the <code>$qname</code> has a prefix and if there is no
namespace binding for <code>$element</code> that matches this
prefix, then an error is raised [<a href="#ERRFONS0004" title="err:FONS0004">err:FONS0004</a>].</rule>
    <rule>If the <code>$qname</code> has no prefix, and there is no
namespace binding for <code>$element</code> corresponding to the
default (unnamed) namespace, then the resulting expanded-QName has
no namespace part.</rule>
    <rule>The prefix (or absence of a prefix) in the supplied
<code>$qname</code> argument is retained in the returned
expanded-QName, as discussed in <a href="http://www.w3.org/TR/xpath-datamodel/#terminology">Section 2.1
Terminology</a>
      <sup>
        <small>DM</small>
      </sup>.</rule>
    <example>Assume that the element bound to <code>$element</code> has a
single namespace binding bound to the prefix <code>eg</code>.</example>
    <example>
      <code>fn:resolve-QName("hello", $element)</code> returns a QName
with local name "hello" that is in no namespace.</example>
    <example>
      <code>fn:resolve-QName("eg:myFunc", $element)</code> returns an
<code>xs:QName</code> whose namespace URI is specified by the
namespace binding corresponding to the prefix "eg" and whose local
name is "myFunc".</example>
  </function>
  <function name="QName" type="xs:QName">
    <signature>
      <arg name="paramURI" type="xs:string?"/>
      <arg name="paramQName" type="xs:string"/>
    </signature>
    <summary>Constructs an <code>xs:QName</code> value given a namespace URI
and a lexical QName.</summary>
    <rule>The namespace URI in the returned QName is taken from
<code>$paramURI</code>. If <code>$paramURI</code> is the
zero-length string or the empty sequence, it represents "no
namespace".</rule>
    <rule>The prefix (or absence of a prefix) in <code>$paramQName</code>
is retained in the returned <code>xs:QName</code> value.</rule>
    <rule>The local name in the result is taken from the local part of
<code>$paramQName</code>.</rule>
    <example>
      <code>fn:QName("http://www.example.com/example",
"person")</code> returns an <code>xs:QName</code> with namespace
URI = "http://www.example.com/example", local name = "person" and
prefix = "".</example>
    <example>
      <code>fn:QName("http://www.example.com/example",
"ht:person")</code> returns an <code>xs:QName</code> with namespace
URI = "http://www.example.com/example", local name = "person" and
prefix = "ht".</example>
  </function>
  <function name="prefix-from-QName" type="xs:NCName?">
    <signature>
      <arg name="arg" type="xs:QName?"/>
    </signature>
    <summary>Returns the prefix component of the supplied QName.</summary>
    <rule>If <code>$arg</code> is the empty sequence the function returns
the empty sequence.</rule>
    <rule>If <code>$arg</code> has no prefix component the function
returns the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:NCName</code>
representing the prefix component of <code>$arg</code>.</rule>
  </function>
  <function name="local-name-from-QName" type="xs:NCName?">
    <signature>
      <arg name="arg" type="xs:QName?"/>
    </signature>
    <summary>Returns the local part of the supplied QName.</summary>
    <rule>If <code>$arg</code> is the empty sequence the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:NCName</code>
representing the local part of <code>$arg</code>.</rule>
    <example>The expression
<code>fn:local-name-from-QName(fn:QName("http://www.example.com/example",
"person"))</code> returns <code>"person"</code>.</example>
  </function>
  <function name="namespace-uri-from-QName" type="xs:anyURI?">
    <signature>
      <arg name="arg" type="xs:QName?"/>
    </signature>
    <summary>Returns the namespace URI part of the supplied QName.</summary>
    <rule>If <code>$arg</code> is the empty sequence the function returns
the empty sequence.</rule>
    <rule>Otherwise, the function returns an <code>xs:anyURI</code>
representing the namespace URI part of <code>$arg</code>.</rule>
    <rule>If <code>$arg</code> is in no namespace, the function returns
the zero-length <code>xs:anyURI</code>.</rule>
    <example>The expression
<code>fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",
"person"))</code> returns
<code>xs:anyURI("http://www.example.com/example")</code>.</example>
  </function>
  <function name="namespace-uri-for-prefix" type="xs:anyURI?">
    <signature>
      <arg name="prefix" type="xs:string?"/>
      <arg name="element" type="element()"/>
    </signature>
    <summary>Returns the namespace URI of one of the in-scope namespaces for
<code>$element</code>, identified by its namespace prefix.</summary>
    <rule>If <code>$element</code> has an in-scope namespace whose
namespace prefix is equal to <code>$prefix</code>, it returns the
namespace URI of that namespace. If <code>$prefix</code> is the
zero-length string or the empty sequence, it returns the namespace
URI of the default (unnamed) namespace. Otherwise, it returns the
empty sequence.</rule>
    <rule>Prefixes are equal only if their Unicode codepoints match
exactly.</rule>
  </function>
  <function name="in-scope-prefixes" type="xs:string*">
    <signature>
      <arg name="element" type="element()"/>
    </signature>
    <summary>Returns the prefixes of the in-scope namespaces for an element
node.</summary>
    <rule>The function returns a sequence of strings representing the
prefixes of the in-scope namespaces for <code>$element</code>.</rule>
    <rule>For namespace bindings that have a prefix, the function returns
the prefix as an <code>xs:NCName</code>. For the default namespace,
which has no prefix, it returns the zero-length string.</rule>
    <rule>The result sequence contains no duplicates.</rule>
    <rule>The ordering of the result sequence is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation-dependent<span class="arrow">·</span>
      </a>.</rule>
  </function>
  <function name="name" type="xs:string">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the name of a node, as an <code>xs:string</code> that is
either the zero-length string, or has the lexical form of an
<code>xs:QName</code>.</summary>
    <rule>If the argument is omitted, it defaults to the context item
(<code>.</code>). The behavior of the function if the argument is
omitted is exactly the same as if the context item had been passed
as the argument.</rule>
    <rule>If the argument is supplied and is the empty sequence, the
function returns the zero-length string.</rule>
    <rule>If the node identified by <code>$arg</code> has no name (that
is, if it is a document node, a comment, a text node, or a
namespace node having no name), the function returns the
zero-length string.</rule>
    <rule>Otherwise, the function returns the value of the expression
<a href="#func-string">
        <code>fn:string(fn:node-name($arg))</code>
      </a>.</rule>
  </function>
  <function name="local-name" type="xs:string">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the local part of the name of <code>$arg</code> as an
<code>xs:string</code> that is either the zero-length string, or
has the lexical form of an <code>xs:NCName</code>.</summary>
    <rule>If the argument is omitted, it defaults to the context item
(<code>.</code>). The behavior of the function if the argument is
omitted is exactly the same as if the context item had been passed
as the argument.</rule>
    <rule>If the argument is supplied and is the empty sequence, the
function returns the zero-length string.</rule>
    <rule>If the node identified by <code>$arg</code> has no name (that
is, if it is a document node, a comment, a text node, or a
namespace node having no name), the function returns the
zero-length string.</rule>
    <rule>Otherwise, the function returns the local part of the
expanded-QName of the node identified by <code>$arg</code>, as
determined by the <code>dm:node-name</code> accessor defined in
<a href="http://www.w3.org/TR/xpath-datamodel/#dm-node-name">Section 5.11
node-name Accessor</a>
      <sup>
        <small>DM</small>
      </sup>). This will be
an <code>xs:string</code> whose lexical form is an
<code>xs:NCName</code>.</rule>
  </function>
  <function name="namespace-uri" type="xs:anyURI">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the namespace URI part of the name of <code>$arg</code>,
as an <code>xs:anyURI</code> value.</summary>
    <rule>If the argument is omitted, it defaults to the context node
(<code>.</code>). The behavior of the function if the argument is
omitted is exactly the same as if the context item had been passed
as the argument.</rule>
    <rule>If the node identified by <code>$arg</code> is neither an
element nor an attribute node, or if it is an element or attribute
node whose expanded-QName (as determined by the
<code>dm:node-name</code> accessor in the <a href="http://www.w3.org/TR/xpath-datamodel/#dm-node-name">Section 5.11
node-name Accessor</a>
      <sup>
        <small>DM</small>
      </sup>) is in no
namespace, then the function returns the zero-length
<code>xs:anyURI</code> value.</rule>
    <rule>Otherwise, the result will be the namespace URI part of the
expanded-QName of the node identified by <code>$arg</code>, as
determined by the <code>dm:node-name</code> accessor defined in
<a href="http://www.w3.org/TR/xpath-datamodel/#dm-node-name">Section 5.11
node-name Accessor</a>
      <sup>
        <small>DM</small>
      </sup>), returned as an
<code>xs:anyURI</code> value.</rule>
  </function>
  <function name="number" type="xs:double">
    <signature/>
    <signature>
      <arg name="arg" type="xs:anyAtomicType?"/>
    </signature>
    <summary>Returns the value indicated by <code>$arg</code> or, if
<code>$arg</code> is not specified, the context item after
atomization, converted to an <code>xs:double</code>.</summary>
    <rule>Calling the zero-argument version of the function is defined to
give the same result as calling the single-argument version with
the context item (<code>.</code>). That is,
<code>fn:number()</code> is equivalent to
<code>fn:number(.)</code>.</rule>
    <rule>If <code>$arg</code> is the empty sequence or if
<code>$arg</code> or the context item cannot be converted to an
<code>xs:double</code>, the <code>xs:double</code> value
<code>NaN</code> is returned.</rule>
    <rule>Otherwise, <code>$arg</code>, or the context item after
atomization, is converted to an <code>xs:double</code> following
the rules of <a href="#casting-to-double">
        <b>18.1.3.2 Casting to
xs:double</b>
      </a>. If the conversion to <code>xs:double</code>
fails, the <code>xs:double</code> value <code>NaN</code> is
returned.</rule>
    <example>The expression <code>fn:number($item1/quantity)</code> returns
<code>5.0e0</code>.</example>
    <example>The expression <code>fn:number($item2/description)</code>
returns <code>xs:double('NaN')</code>.</example>
    <example>Assume that the context item is the <code>xs:string</code> value
"<code>15</code>". Then <code>fn:number()</code> returns
<code>1.5e1</code>.</example>
  </function>
  <function name="lang" type="xs:boolean">
    <signature>
      <arg name="testlang" type="xs:string?"/>
    </signature>
    <signature>
      <arg name="testlang" type="xs:string?"/>
      <arg name="node" type="node()"/>
    </signature>
    <summary>This function tests whether the language of <code>$node</code>,
or the context item if the second argument is omitted, as specified
by <code>xml:lang</code> attributes is the same as, or is a
sublanguage of, the language specified by
<code>$testlang</code>.</summary>
    <rule>The behavior of the function if the second argument is omitted
is exactly the same as if the context item (<code>.</code>) had
been passed as the second argument.</rule>
    <rule>The language of the argument <code>$node</code>, or the context
item if the second argument is omitted, is determined by the value
of the <code>xml:lang</code> attribute on the node, or, if the node
has no such attribute, by the value of the <code>xml:lang</code>
attribute on the nearest ancestor of the node that has an
<code>xml:lang</code> attribute. If there is no such ancestor, then
the function returns <code>false</code>.</rule>
    <rule>If <code>$testlang</code> is the empty sequence it is
interpreted as the zero-length string.</rule>
    <rule>The relevant <code>xml:lang</code> attribute is determined by
the value of the XPath expression:</rule>
    <rule>If this expression returns an empty sequence, the function
returns <code>false</code>.</rule>
    <rule>Otherwise, the function returns <code>true</code> if and only
if, based on a caseless default match as specified in section 3.13
of <a href="#Unicode4">[The Unicode Standard]</a>, either:</rule>
    <example>The expression <code>fn:lang("en")</code> would return
<code>true</code> if the context node were any of the following
four elements:</example>
    <example>The expression <code>fn:lang("fr")</code> would return
<code>false</code> if the context node were <code>&lt;para
xml:lang="EN"/&gt;</code>
    </example>
  </function>
  <function name="root" type="node()">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>Returns the root of the tree to which <code>$arg</code> belongs.
This will usually, but not necessarily, be a document node.</summary>
    <rule>If the function is called without an argument, the context item
(<code>.</code>) is used as the default argument. The behavior of
the function if the argument is omitted is exactly the same as if
the context item had been passed as the argument.</rule>
    <rule>The function returns the value of the expression
<code>($arg/ancestor-or-self::node())[1]</code>.</rule>
    <example>These examples use some variables which could be defined in
<a href="#xquery">[XQuery 1.0: An XML Query Language]</a> as:</example>
    <example>Or they could be defined in <a href="#xslt20">[XSL
Transformations (XSLT) Version 2.0]</a> as:</example>
    <example>
      <code>fn:root($i)</code> returns the element node
<code>$i</code>
    </example>
    <example>
      <code>fn:root($o/quantity)</code> returns the element node
<code>$o</code>
    </example>
    <example>
      <code>fn:root($odoc//quantity)</code> returns the document node
<code>$odoc</code>
    </example>
    <example>
      <code>fn:root($newi)</code> returns the element node
<code>$o</code>
    </example>
    <example>The final three examples could be made type-safe by wrapping
their operands with <a href="#func-exactly-one">
        <code>fn:exactly-one()</code>
      </a>.</example>
  </function>
  <function name="distinct-values" type="xs:anyAtomicType*">
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns the values that appear in a sequence, with duplicates
eliminated.</summary>
    <rule>The function returns the sequence that results from removing
from <code>$arg</code> all but one of a set of values that are
equal to one another. Values are compared using the <code>eq</code>
operator, subject to the caveats defined below.</rule>
    <rule>Values of type <code>xs:untypedAtomic</code> are compared as if
they were of type <code>xs:string</code>.</rule>
    <rule>Values that cannot be compared, because the <code>eq</code>
operator is not defined for their types, are considered to be
distinct.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>. This collation is used when string comparison is
required.</rule>
    <rule>For <code>xs:float</code> and <code>xs:double</code> values,
positive zero is equal to negative zero and, although
<code>NaN</code> does not equal itself, if <code>$arg</code>
contains multiple <code>NaN</code> values a single <code>NaN</code>
is returned.</rule>
    <rule>If <code>xs:dateTime</code>, <code>xs:date</code> or
<code>xs:time</code> values do not have a timezone, they are
considered to have the implicit timezone provided by the dynamic
context for the purpose of comparison. Note that
<code>xs:dateTime</code>, <code>xs:date</code> or
<code>xs:time</code> values can compare equal even if their
timezones are different.</rule>
    <rule>The order in which the sequence of values is returned is
<a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <rule>Which value of a set of values that compare equal is returned is
<a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <rule>The static type of the result is a sequence of prime types as
defined in <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_distinct_node_vals">Section
7.2.7 The fn:distinct-values
function</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <rule>If the input sequence contains values of different numeric types
that differ from each other by small amounts, then the eq operator
is not transitive, because of rounding effects occurring during
type promotion. In the situation where the input contains three
values <code>A</code>, <code>B</code>, and <code>C</code> such that
<code>A eq B</code>, <code>B eq C</code>, but <code>A ne C</code>,
then the number of items in the result of the function (as well as
the choice of which items are returned) is
implementation-dependent, subject only to the constraints that (a)
no two items in the result sequence compare equal to each other,
and (b) every input item that does not appear in the result
sequence compares equal to some item that does appear in the result
sequence.</rule>
    <rule>For example, this arises when computing:</rule>
    <rule>because the values of type <code>xs:float</code> and
<code>xs:double</code> both compare equal to the value of type
<code>xs:decimal</code> but not equal to each other.</rule>
    <example>The expression <code>fn:distinct-values((1, 2.0, 3, 2))</code>
returns some permutation of <code>(1, 3, 2.0)</code>.</example>
    <example>The expression
<code>fn:distinct-values((xs:untypedAtomic("cherry"),
xs:untypedAtomic("plum"), xs:untypedAtomic("plum")))</code> returns
some permutation of <code>(xs:untypedAtomic("cherry"),
xs:untypedAtomic("plum"))</code>.</example>
  </function>
  <function name="empty" type="xs:boolean">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns true if the argument is the empty sequence.</summary>
    <rule>If the value of <code>$arg</code> is the empty sequence, the
function returns <code>true</code>; otherwise, the function returns
<code>false</code>.</rule>
    <example>The expression <code>fn:empty((1,2,3)[10])</code> returns
<code>true()</code>.</example>
    <example>The expression <code>fn:empty(fn:remove(("hello", "world"),
1))</code> returns <code>false()</code>.</example>
  </function>
  <function name="exists" type="xs:boolean">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns true if the argument is a non-empty sequence.</summary>
    <rule>If the value of <code>$arg</code> is a non-empty sequence, the
function returns <code>true</code>; otherwise, the function returns
<code>false</code>.</rule>
    <example>The expression <code>fn:exists(fn:remove(("hello"), 1))</code>
returns <code>false()</code>.</example>
    <example>The expression <code>fn:exists(fn:remove(("hello", "world"),
1))</code> returns <code>true()</code>.</example>
  </function>
  <function name="index-of" type="xs:integer*">
    <signature>
      <arg name="seqArg" type="xs:anyAtomicType*"/>
      <arg name="searchArg" type="xs:anyAtomicType"/>
    </signature>
    <signature>
      <arg name="seqArg" type="xs:anyAtomicType*"/>
      <arg name="searchArg" type="xs:anyAtomicType"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns a sequence of positive integers giving the positions
within the sequence <code>$seqArg</code> of items that are equal to
<code>$searchArg</code>.</summary>
    <rule>The function returns a sequence of positive integers giving the
positions within the sequence <code>$seqArg</code> of items that
are equal to <code>$searchArg</code>.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>. This collation is used when string comparison is
required.</rule>
    <rule>The items in the sequence <code>$seqArg</code> are compared with
<code>$searchArg</code> under the rules for the <code>eq</code>
operator. Values of type <code>xs:untypedAtomic</code> are compared
as if they were of type <code>xs:string</code>. Values that cannot
be compared, because the <code>eq</code> operator is not defined
for their types, are considered to be distinct. If an item compares
equal, then the position of that item in the sequence
<code>$seqArg</code> is included in the result.</rule>
    <rule>The first item in a sequence is at position 1, not position
0.</rule>
    <rule>The result sequence is in ascending numeric order.</rule>
    <example>The expression <code>fn:index-of((10, 20, 30, 40), 35)</code>
returns <code>()</code>.</example>
    <example>The expression <code>fn:index-of((10, 20, 30, 30, 20, 10),
20)</code> returns <code>(2, 5)</code>.</example>
    <example>The expression <code>fn:index-of(("a", "sport", "and", "a",
"pastime"), "a")</code> returns <code>(1, 4)</code>.</example>
    <example>If <code>@a</code> is an attribute of type
<code>xs:NMTOKENS</code> whose string value is <code>"red green
blue"</code>, and whose typed value is therefore <code>("red",
"green", "blue")</code> then <code>fn:index-of(@a, "blue")</code>
returns <code>3</code>. This is because the function calling
mechanism atomizes the attribute node to produce a sequence of
three <code>xs:NMTOKEN</code> values.</example>
  </function>
  <function name="insert-before" type="item()*">
    <signature>
      <arg name="target" type="item()*"/>
      <arg name="position" type="xs:integer"/>
      <arg name="inserts" type="item()*"/>
    </signature>
    <summary>Returns a sequence constructed by inserting an item or a
sequence of items at a given position within an existing
sequence.</summary>
    <rule>The value returned by the function consists of all items of
<code>$target</code> whose index is less than
<code>$position</code>, followed by all items of
<code>$inserts</code>, followed by the remaining elements of
<code>$target</code>, in that order.</rule>
    <rule>For detailed type semantics see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_insert_before">Section
7.2.15 The fn:insert-before
function</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$abc</code> := <code>("a", "b", "c")</code>
    </example>
    <example>The expression <code>fn:insert-before($abc, 0, "z")</code>
returns <code>("z", "a", "b", "c")</code>.</example>
    <example>The expression <code>fn:insert-before($abc, 1, "z")</code>
returns <code>("z", "a", "b", "c")</code>.</example>
    <example>The expression <code>fn:insert-before($abc, 2, "z")</code>
returns <code>("a", "z", "b", "c")</code>.</example>
    <example>The expression <code>fn:insert-before($abc, 3, "z")</code>
returns <code>("a", "b", "z", "c")</code>.</example>
    <example>The expression <code>fn:insert-before($abc, 4, "z")</code>
returns <code>("a", "b", "c", "z")</code>.</example>
  </function>
  <function name="remove" type="item()*">
    <signature>
      <arg name="target" type="item()*"/>
      <arg name="position" type="xs:integer"/>
    </signature>
    <summary>Returns a new sequence containing all the items of
<code>$target</code> except the item at position
<code>$position</code>.</summary>
    <rule>The function returns a sequence consisting of all items of
<code>$target</code> whose index is less than
<code>$position</code>, followed by all items of
<code>$target</code> whose index is greater than
<code>$position</code>.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_remove">Section
7.2.11 The fn:remove function</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$abc</code> := <code>("a", "b", "c")</code>
    </example>
    <example>The expression <code>fn:remove($abc, 0)</code> returns
<code>("a", "b", "c")</code>.</example>
    <example>The expression <code>fn:remove($abc, 1)</code> returns
<code>("b", "c")</code>.</example>
    <example>The expression <code>fn:remove($abc, 6)</code> returns
<code>("a", "b", "c")</code>.</example>
    <example>The expression <code>fn:remove((), 3)</code> returns
<code>()</code>.</example>
  </function>
  <function name="reverse" type="item()*">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Reverses the order of items in a sequence.</summary>
    <rule>The function returns a sequence containing the items in
<code>$arg</code> in reverse order.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_reverse">Section
7.2.12 The fn:reverse function</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
    <example>let <code>$abc</code> := <code>("a", "b", "c")</code>
    </example>
    <example>The expression <code>fn:reverse($abc)</code> returns <code>("c",
"b", "a")</code>.</example>
    <example>The expression <code>fn:reverse(("hello"))</code> returns
<code>("hello")</code>.</example>
    <example>The expression <code>fn:reverse(())</code> returns
<code>()</code>.</example>
  </function>
  <function name="subsequence" type="item()*">
    <signature>
      <arg name="sourceSeq" type="item()*"/>
      <arg name="startingLoc" type="xs:double"/>
    </signature>
    <signature>
      <arg name="sourceSeq" type="item()*"/>
      <arg name="startingLoc" type="xs:double"/>
      <arg name="length" type="xs:double"/>
    </signature>
    <summary>Returns the contiguous sequence of items in the value of
<code>$sourceSeq</code> beginning at the position indicated by the
value of <code>$startingLoc</code> and continuing for the number of
items indicated by the value of <code>$length</code>.</summary>
    <rule>In the two-argument case, returns:</rule>
    <rule>In the three-argument case, returns:</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_subsequence">Section
7.2.13 The fn:subsequence
function</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$seq</code> := <code>("item1", "item2", "item3",
"item4", "item5")</code>
    </example>
    <example>The expression <code>fn:subsequence($seq, 4)</code> returns
<code>("item4", "item5")</code>.</example>
    <example>The expression <code>fn:subsequence($seq, 3, 2)</code> returns
<code>("item3", "item4")</code>.</example>
  </function>
  <function name="unordered" type="item()*">
    <signature>
      <arg name="sourceSeq" type="item()*"/>
    </signature>
    <summary>Returns the items of <code>$sourceSeq</code> in an <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a> order.</summary>
    <rule>The function returns the items of <code>$sourceSeq</code> in an
<a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a> order.</rule>
    <example>The expression <code>fn:unordered((1, 2, 3, 4, 5))</code>
returns some permutation of <code>(1, 2, 3, 4, 5)</code>.</example>
  </function>
  <function name="zero-or-one" type="item()?">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns <code>$arg</code> if it contains zero or one items.
Otherwise, raises an error.</summary>
    <rule>Except in error cases, the function returns <code>$arg</code>
unchanged.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section
7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one
functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
  </function>
  <function name="one-or-more" type="item()+">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns <code>$arg</code> if it contains one or more items.
Otherwise, raises an error.</summary>
    <rule>Except in error cases, the function returns <code>$arg</code>
unchanged.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section
7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one
functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
  </function>
  <function name="exactly-one" type="item()">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns <code>$arg</code> if it contains exactly one item.
Otherwise, raises an error.</summary>
    <rule>Except in error cases, the function returns <code>$arg</code>
unchanged.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section
7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one
functions</a>
      <sup>
        <small>FS</small>
      </sup>
    </rule>
  </function>
  <function name="deep-equal" type="xs:boolean">
    <signature>
      <arg name="parameter1" type="item()*"/>
      <arg name="parameter2" type="item()*"/>
    </signature>
    <signature>
      <arg name="parameter1" type="item()*"/>
      <arg name="parameter2" type="item()*"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>This function assesses whether two sequences are deep-equal to
each other. To be deep-equal, they must contain items that are
pairwise deep-equal; and for two items to be deep-equal, they must
either be atomic values that compare equal, or nodes of the same
kind, with the same name, whose children are deep-equal.</summary>
    <rule>The <code>$collation</code> argument identifies a collation
which is used at all levels of recursion when strings are compared
(but not when names are compared), according to the rules in
<a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>If the two sequences are both empty, the function returns
<code>true</code>.</rule>
    <rule>If the two sequences are of different lengths, the function
returns <code>false</code>.</rule>
    <rule>If the two sequences are of the same length, the function
returns <code>true</code> if and only if every item in the sequence
<code>$parameter1</code> is deep-equal to the item at the same
position in the sequence <code>$parameter2</code>. The rules for
deciding whether two items are deep-equal follow.</rule>
    <rule>Call the two items <code>$i1</code> and <code>$i2</code>
respectively.</rule>
    <rule>If <code>$i1</code> and <code>$i2</code> are both atomic values,
they are deep-equal if and only if <code>($i1 eq $i2)</code> is
<code>true</code>, or if both values are <code>NaN</code>. If the
<code>eq</code> operator is not defined for <code>$i1</code> and
<code>$i2</code>, the function returns <code>false</code>.</rule>
    <rule>If one of the pair <code>$i1</code> or <code>$i2</code> is an
atomic value and the other is a node, the function returns
<code>false</code>.</rule>
    <rule>If <code>$i1</code> and <code>$i2</code> are both nodes, they
are compared as described below:</rule>
    <example>let <code>$at</code> :=</example>
    <example>The expression <code>fn:deep-equal($at, $at/*)</code> returns
<code>false()</code>.</example>
    <example>The expression <code>fn:deep-equal($at/name[1],
$at/name[2])</code> returns <code>false()</code>.</example>
    <example>The expression <code>fn:deep-equal($at/name[1],
$at/name[3])</code> returns <code>true()</code>.</example>
    <example>The expression <code>fn:deep-equal($at/name[1], 'Peter
Parker')</code> returns <code>false()</code>.</example>
  </function>
  <function name="count" type="xs:integer">
    <signature>
      <arg name="arg" type="item()*"/>
    </signature>
    <summary>Returns the number of items in a sequence.</summary>
    <rule>The function returns the number of items in the value of
<code>$arg</code>.</rule>
    <example>let <code>$seq1</code> := <code>($item1, $item2)</code>
    </example>
    <example>let <code>$seq2</code> := <code>(98.5, 98.3, 98.9)</code>
    </example>
    <example>let <code>$seq3</code> := <code>()</code>
    </example>
    <example>The expression <code>fn:count($seq1)</code> returns
<code>2</code>.</example>
    <example>The expression <code>fn:count($seq3)</code> returns
<code>0</code>.</example>
    <example>The expression <code>fn:count($seq2)</code> returns
<code>3</code>.</example>
    <example>The expression <code>fn:count($seq2[. &gt; 100])</code> returns
<code>0</code>.</example>
  </function>
  <function name="avg" type="xs:anyAtomicType?">
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
    </signature>
    <summary>Returns the average of the values in the input sequence
<code>$arg</code>, that is, the sum of the values divided by the
number of values.</summary>
    <rule>If <code>$arg</code> is the empty sequence, the empty sequence
is returned.</rule>
    <rule>If <code>$arg</code> contains values of type
<code>xs:untypedAtomic</code> they are cast to
<code>xs:double</code>.</rule>
    <rule>Duration values must either all be
<code>xs:yearMonthDuration</code> values or must all be
<code>xs:dayTimeDuration</code> values. For numeric values, the
numeric promotion rules defined in <a href="#op.numeric">
        <b>4.2
Arithmetic Operators on Numeric Values</b>
      </a> are used to promote
all values to a single common type. After these operations,
<code>$arg</code> must contain items of a single type, which must
be one of the four numeric types, <code>xs:yearMonthDuration</code>
or <code>xs:dayTimeDuration</code> or one if its subtypes.</rule>
    <rule>The function returns the average of the values as
<code>sum($arg) div count($arg)</code>; but the implementation may
use an otherwise equivalent algorithm that avoids arithmetic
overflow.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section
7.2.10 The fn:min, fn:max, fn:avg, and fn:sum
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$d1</code> :=
<code>xs:yearMonthDuration("P20Y")</code>
    </example>
    <example>let <code>$d2</code> :=
<code>xs:yearMonthDuration("P10M")</code>
    </example>
    <example>let <code>$seq3</code> := <code>(3, 4, 5)</code>
    </example>
    <example>The expression <code>fn:avg($seq3)</code> returns
<code>4.0</code>. <em>(The result is of type
<code>xs:decimal</code>.).</em>
    </example>
    <example>The expression <code>fn:avg(($d1, $d2))</code> returns
<code>xs:yearMonthDuration("P10Y5M")</code>.</example>
    <example>
      <code>fn:avg(($d1, $seq3))</code> raises a type error [<a href="#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>].</example>
    <example>The expression <code>fn:avg(())</code> returns
<code>()</code>.</example>
    <example>The expression <code>fn:avg((xs:float('INF'),
xs:float('-INF')))</code> returns <code>xs:float('NaN')</code>.</example>
    <example>The expression <code>fn:avg(($seq3, xs:float('NaN')))</code>
returns <code>xs:float('NaN')</code>.</example>
  </function>
  <function name="max" type="xs:anyAtomicType?">
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns a value that is equal to the highest value appearing in
the input sequence.</summary>
    <rule>The following rules are applied to the input sequence
<code>$arg</code>:</rule>
    <rule>The items in the resulting sequence may be reordered in an
arbitrary order. The resulting sequence is referred to below as the
converted sequence. The function returns an item from the converted
sequence rather than the input sequence.</rule>
    <rule>If the converted sequence is empty, the function returns the
empty sequence.</rule>
    <rule>All items in the <span>converted sequence must be derived</span>
from a single base type for which the <code>le</code> operator is
defined. In addition, the values in the sequence must have a total
order. If date/time values do not have a timezone, they are
considered to have the implicit timezone provided by the dynamic
context for the purpose of comparison. Duration values must either
all be <code>xs:yearMonthDuration</code> values or must all be
<code>xs:dayTimeDuration</code> values.</rule>
    <rule>If the converted sequence contains the value <code>NaN</code>,
the value <code>NaN</code> is returned.</rule>
    <rule>If the items in the <span>converted sequence</span> are of type
<code>xs:string</code> or types derived by restriction from
<code>xs:string</code>, then the determination of the item with the
smallest value is made according to the collation that is used. If
the type of the items in the <span>converted sequence</span> is not
<code>xs:string</code> and <code>$collation</code> is specified,
the collation is ignored.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns the result of the expression:</rule>
    <rule>evaluated with <code>$collation</code> as the default collation
if specified, and with <code>$c</code> as the converted
sequence.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section
7.2.10 The fn:min, fn:max, fn:avg, and fn:sum
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>The expression <code>fn:max((3,4,5))</code> returns
<code>5</code>.</example>
    <example>The expression <code>fn:max((xs:integer(5), xs:float(5.0),
xs:double(0)))</code> returns <code>xs:double(5.0e0)</code>.</example>
    <example>
      <code>fn:max((3,4,"Zero"))</code> raises a type error [<a href="#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>].</example>
    <example>The expression <code>fn:max((fn:current-date(),
xs:date("2100-01-01")))</code> returns
<code>xs:date("2100-01-01")</code>. <em>(Assuming that the current
date is during the 21st century.).</em>
    </example>
    <example>The expression <code>fn:max(("a", "b", "c"))</code> returns
<code>"c"</code>. <em>(Assuming a typical default
collation.).</em>
    </example>
  </function>
  <function name="min" type="xs:anyAtomicType?">
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
      <arg name="collation" type="xs:string"/>
    </signature>
    <summary>Returns a value that is equal to the lowest value appearing in
the input sequence.</summary>
    <rule>The following rules are applied to the input sequence:</rule>
    <rule>The items in the resulting sequence may be reordered in an
arbitrary order. The resulting sequence is referred to below as the
converted sequence. The function returns an item from the converted
sequence rather than the input sequence.</rule>
    <rule>If the converted sequence is empty, the empty sequence is
returned.</rule>
    <rule>All items in the <span>converted sequence must be derived</span>
from a single base type for which the <code>le</code> operator is
defined. In addition, the values in the sequence must have a total
order. If date/time values do not have a timezone, they are
considered to have the implicit timezone provided by the dynamic
context for the purpose of comparison. Duration values must either
all be <code>xs:yearMonthDuration</code> values or must all be
<code>xs:dayTimeDuration</code> values.</rule>
    <rule>If the converted sequence contains the value <code>NaN</code>,
the value <code>NaN</code> is returned.</rule>
    <rule>If the items in the <span>converted sequence</span> are of type
<code>xs:string</code> or types derived by restriction from
<code>xs:string</code>, then the determination of the item with the
smallest value is made according to the collation that is used. If
the type of the items in the <span>converted sequence</span> is not
<code>xs:string</code> and <code>$collation</code> is specified,
the collation is ignored.</rule>
    <rule>The collation used by this function is determined according to
the rules in <a href="#choosing-a-collation">
        <b>5.3.3 Choosing a
Collation</b>
      </a>.</rule>
    <rule>The function returns the result of the expression:</rule>
    <rule>evaluated with <code>$collation</code> as the default collation
if specified, and with <code>$c</code> as the converted
sequence.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section
7.2.10 The fn:min, fn:max, fn:avg, and fn:sum
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>The expression <code>fn:min((3,4,5))</code> returns
<code>3</code>.</example>
    <example>The expression <code>fn:min((xs:integer(5), xs:float(5),
xs:double(10)))</code> returns <code>xs:double(5.0e0)</code>.</example>
    <example>
      <code>fn:min((3,4,"Zero"))</code> raises a type error [<a href="#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>].</example>
    <example>
      <code>fn:min((xs:float(0.0E0), xs:float(-0.0E0)))</code> can
return either positive or negative zero. <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>
does not distinguish between the values positive zero and negative
zero. The result is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</example>
    <example>The expression <code>fn:min((fn:current-date(),
xs:date("1900-01-01")))</code> returns
<code>xs:date("1900-01-01")</code>. <em>(Assuming that the current
date is set to a reasonable value.).</em>
    </example>
    <example>The expression <code>fn:min(("a", "b", "c"))</code> returns
<code>"a"</code>. <em>(Assuming a typical default
collation.).</em>
    </example>
  </function>
  <function name="sum" type="xs:anyAtomicType">
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:anyAtomicType*"/>
      <arg name="zero" type="xs:anyAtomicType?"/>
    </signature>
    <summary>Returns a value obtained by adding together the values in
<code>$arg</code>.</summary>
    <rule>Any values of type <code>xs:untypedAtomic</code> in
<code>$arg</code> are cast to <code>xs:double</code>. The items in
the resulting sequence may be reordered in an arbitrary order. The
resulting sequence is referred to below as the converted
sequence.</rule>
    <rule>If the converted sequence is empty, then the single-argument
form of the function returns the <code>xs:integer</code> value
<code>0</code>; the two-argument form returns the value of the
argument <code>$zero</code>.</rule>
    <rule>If the converted sequence contains the value <code>NaN</code>,
<code>NaN</code> is returned.</rule>
    <rule>All items in <code>$arg</code> must be numeric or derived from a
single base type. In addition, the type must support addition.
Duration values must either all be
<code>xs:yearMonthDuration</code> values or must all be
<code>xs:dayTimeDuration</code> values. For numeric values, the
numeric promotion rules defined in <a href="#op.numeric">
        <b>4.2
Arithmetic Operators on Numeric Values</b>
      </a> are used to promote
all values to a single common type. The sum of a sequence of
integers will therefore be an integer, while the sum of a numeric
sequence that includes at least one <code>xs:double</code> will be
an <code>xs:double</code>.</rule>
    <rule>The result of the function, using the second signature, is the
result of the expression:</rule>
    <rule>where <code>$c</code> is the converted sequence.</rule>
    <rule>The result of the function, using the first signature, is the
result of the expression: <code>fn:sum($arg, 0)</code>.</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section
7.2.10 The fn:min, fn:max, fn:avg, and fn:sum
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <example>let <code>$d1</code> :=
<code>xs:yearMonthDuration("P20Y")</code>
    </example>
    <example>let <code>$d2</code> :=
<code>xs:yearMonthDuration("P10M")</code>
    </example>
    <example>let <code>$seq1</code> := <code>($d1, $d2)</code>
    </example>
    <example>let <code>$seq3</code> := <code>(3, 4, 5)</code>
    </example>
    <example>The expression <code>fn:sum(($d1, $d2))</code> returns
<code>xs:yearMonthDuration("P20Y10M")</code>.</example>
    <example>The expression <code>fn:sum($seq1[. lt
xs:yearMonthDuration('P3M')], xs:yearMonthDuration('P0M'))</code>
returns <code>xs:yearMonthDuration("P0M")</code>.</example>
    <example>The expression <code>fn:sum($seq3)</code> returns
<code>12</code>.</example>
    <example>The expression <code>fn:sum(())</code> returns
<code>0</code>.</example>
    <example>The expression <code>fn:sum((),())</code> returns
<code>()</code>.</example>
    <example>The expression <code>fn:sum((1 to 100)[. lt 0], 0)</code>
returns <code>0</code>.</example>
    <example>
      <code>fn:sum(($d1, 9E1))</code> raises an error [<a href="#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>].</example>
    <example>The expression <code>fn:sum(($d1, $d2), "ein Augenblick")</code>
returns <code>xs:yearMonthDuration("P20Y10M")</code>. <em>(There is
no requirement that the <code>$zero</code> value should be the same
type as the items in <code>$arg</code>, or even that it should
belong to a type that supports addition.).</em>
    </example>
  </function>
  <function name="id" type="element()*">
    <signature>
      <arg name="arg" type="xs:string*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:string*"/>
      <arg name="node" type="node()"/>
    </signature>
    <summary>Returns the sequence of element nodes that have an
<code>ID</code> value matching the value of one or more of the
<code>IDREF</code> values supplied in <code>$arg</code>.</summary>
    <rule>The function returns a sequence, in document order with
duplicates eliminated, containing every element node <code>E</code>
that satisfies all the following conditions:</rule>
    <example>let <code>$emp</code> :=</example>
    <example>The expression <code>id('ID21256')/name()</code> returns
<code>employee</code>. <em>(The <code>xml:id</code> attribute has
the <code>is-id</code> property, so the employee element is
selected.).</em>
    </example>
    <example>The expression <code>id('E21256')/name()</code> returns
<code>empnr</code>. <em>(Assuming the <code>empnr</code> element is
given the type <code>xs:ID</code> as a result of schema validation,
the element will have the <code>is-id</code> property and is
therefore selected. Note the difference from the behavior of
<a href="#func-element-with-id">
          <code>fn:element-with-id</code>
        </a>.).</em>
    </example>
  </function>
  <function name="element-with-id" type="element()*">
    <signature>
      <arg name="arg" type="xs:string*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:string*"/>
      <arg name="node" type="node()"/>
    </signature>
    <summary>Returns the sequence of element nodes that have an
<code>ID</code> value matching the value of one or more of the
<code>IDREF</code> values supplied in <code>$arg</code>.</summary>
    <rule>The function returns a sequence, in document order with
duplicates eliminated, containing every element node <code>E</code>
that satisfies all the following conditions:</rule>
    <example>let <code>$emp</code> :=</example>
    <example>The expression <code>id('ID21256')/name()</code> returns
<code>"employee"</code>. <em>(The <code>xml:id</code> attribute has
the <code>is-id</code> property, so the employee element is
selected.).</em>
    </example>
    <example>The expression <code>id('E21256')/name()</code> returns
<code>"employee"</code>. <em>(Assuming the <code>empnr</code>
element is given the type <code>xs:ID</code> as a result of schema
validation, the element will have the <code>is-id</code> property
and is therefore its parent is selected. Note the difference from
the behavior of <a href="#func-id">
          <code>fn:id</code>
        </a>.).</em>
    </example>
  </function>
  <function name="idref" type="node()*">
    <signature>
      <arg name="arg" type="xs:string*"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:string*"/>
      <arg name="node" type="node()"/>
    </signature>
    <summary>Returns the sequence of element or attribute nodes with an
<code>IDREF</code> value matching the value of one or more of the
<code>ID</code> values supplied in <code>$arg</code>.</summary>
    <rule>The function returns a sequence, in document order with
duplicates eliminated, containing every element or attribute node
<code>$N</code> that satisfies all the following conditions:</rule>
  </function>
  <function name="doc" type="document-node()?">
    <signature>
      <arg name="uri" type="xs:string?"/>
    </signature>
    <summary>Retrieves a document using a URI supplied as an
<code>xs:string</code>, and returns the corresponding document
node.</summary>
    <rule>If <code>$uri</code> is the empty sequence, the result is an
empty sequence.</rule>
    <rule>If <code>$uri</code> is a relative URI reference, it is resolved
relative to the value of the base URI property from the static
context. The resulting absolute URI is promoted to an
<code>xs:string</code>.</rule>
    <rule>If the <b>Available documents</b> described in <a href="http://www.w3.org/TR/xpath20/#eval_context">Section 2.1.2 Dynamic
Context</a>
      <sup>
        <small>XP</small>
      </sup> provides a mapping from
this string to a document node, the function returns that document
node.</rule>
    <rule>The URI may include a fragment identifier.</rule>
    <rule>By default, this function is <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>. Two calls on this function return the same
document node if the same URI Reference (after resolution to an
absolute URI Reference) is supplied to both calls. Thus, the
following expression (if it does not raise an error) will always be
true:</rule>
    <rule>However, for performance reasons, implementations may provide a
user option to evaluate the function without a guarantee of
stability. The manner in which any such option is provided is
implementation-defined. If the user has not selected such an
option, a call of the function must either return a stable result
or must raise an error: [<a href="#ERRFODC0003" title="err:FODC0003">err:FODC0003</a>].</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_doc_collection">Section
7.2.5 The fn:collection and fn:doc
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
    <rule>If two calls to this function supply different absolute URI
References as arguments, the same document node may be returned if
the implementation can determine that the two arguments refer to
the same resource.</rule>
    <rule>By defining the semantics of this function in terms of a
string-to-document-node mapping in the dynamic context, the
specification is acknowledging that the results of this function
are outside the purview of the language specification itself, and
depend entirely on the run-time environment in which the expression
is evaluated. This run-time environment includes not only an
unpredictable collection of resources ("the web"), but configurable
machinery for locating resources and turning their contents into
document nodes within the XPath data model. Both the set of
resources that are reachable, and the mechanisms by which those
resources are parsed and validated, are <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <rule>One possible processing model for this function is as follows.
The resource identified by the URI Reference is retrieved. If the
resource cannot be retrieved, an error is raised [<a href="#ERRFODC0002" title="err:FODC0002">err:FODC0002</a>]. The data
resulting from the retrieval action is then parsed as an XML
document and a tree is constructed in accordance with the <a href="#">[xpath-datamodel]</a>. If the top-level media type is known and
is "text", the content is parsed in the same way as if the media
type were text/xml; otherwise, it is parsed in the same way as if
the media type were application/xml. If the contents cannot be
parsed successfully, an error is raised [<a href="#ERRFODC0002" title="err:FODC0002">err:FODC0002</a>]. Otherwise, the result of
the function is the document node at the root of the resulting
tree. This tree is then optionally validated against a schema.</rule>
    <rule>Various aspects of this processing are <a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a>. Implementations may provide external
configuration options that allow any aspect of the processing to be
controlled by the user. In particular:</rule>
  </function>
  <function name="doc-available" type="xs:boolean">
    <signature>
      <arg name="uri" type="xs:string?"/>
    </signature>
    <summary>The function returns true if and only if the function call
<a href="#func-doc">
        <code>fn:doc($uri)</code>
      </a> would return a
document node.</summary>
    <rule>If <code>$uri</code> is an empty sequence, this function returns
<code>false</code>.</rule>
    <rule>If a call on <a href="#func-doc">
        <code>fn:doc($uri)</code>
      </a>
would return a document node, this function returns
<code>true</code>.</rule>
    <rule>If <code>$uri</code> is not a valid URI according to the rules
applied by the implementation of <a href="#func-doc">
        <code>fn:doc</code>
      </a>, an error is raised [<a href="#ERRFODC0005" title="err:FODC0005">err:FODC0005</a>].</rule>
    <rule>Otherwise, this function returns <code>false</code>.</rule>
    <rule>If this function returns <code>true</code>, then calling
<a href="#func-doc">
        <code>fn:doc($uri)</code>
      </a> within the same
<a title="execution scope" class="termref" href="#execution-scope">
        <span class="arrow">·</span>execution
scope<span class="arrow">·</span>
      </a> must return a document node.
However, if non-stable processing has been selected for the
<a href="#func-doc">
        <code>fn:doc</code>
      </a> function, this
guarantee is lost.</rule>
  </function>
  <function name="collection" type="node()*">
    <signature/>
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Returns a sequence of nodes representing a collection of
documents indentified by a collection URI; or a default collection
if no URI is supplied.</summary>
    <rule>This function takes an <code>xs:string</code> as argument and
returns a sequence of nodes obtained by interpreting
<code>$arg</code> as an <code>xs:anyURI</code> and resolving it
according to the mapping specified in <b>Available collections</b>
described in <a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.</rule>
    <rule>If <b>Available collections</b> provides a mapping from this
string to a sequence of nodes, the function returns that sequence.
If <b>Available collections</b> maps the string to an empty
sequence, then the function returns an empty sequence.</rule>
    <rule>If <code>$arg</code> is not specified, the function returns the
sequence of the nodes in the default collection in the dynamic
context. See <a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.</rule>
    <rule>If the value of <code>$arg</code> is a relative
<code>xs:anyURI</code>, it is resolved against the value of the
base-URI property from the static context.</rule>
    <rule>If <code>$arg</code> is the empty sequence, the function behaves
as if it had been called without an argument. See above.</rule>
    <rule>By default, this function is <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>. This means that repeated calls on the
function with the same argument will return the same result.
However, for performance reasons, implementations may provide a
user option to evaluate the function without a guarantee of
stability. The manner in which any such option is provided is
<a title="implementation-defined" class="termref" href="#implementation-defined">
        <span class="arrow">·</span>implementation-defined<span class="arrow">·</span>
      </a>. If the user has not selected such an option,
a call to this function must either return a stable result or must
raise an error: [<a href="#ERRFODC0003" title="err:FODC0003">err:FODC0003</a>].</rule>
    <rule>For detailed type semantics, see <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_doc_collection">Section
7.2.5 The fn:collection and fn:doc
functions</a>
      <sup>
        <small>FS</small>
      </sup>.</rule>
  </function>
  <function name="uri-collection" type="xs:anyURI*">
    <signature/>
    <signature>
      <arg name="arg" type="xs:string?"/>
    </signature>
    <summary>Returns a sequence of <code>xs:anyURI</code> values representing
the document URIs of the documents in a collection.</summary>
    <rule>A collection, as returned by the <code>fn:collection</code>
function, is in general a sequence of nodes. Some of these nodes
may be document nodes, and some of these document nodes may have a
non-empty document URI, accessible using the
<code>fn:document-uri</code> function. The
<code>fn:uri-collection</code> function returns a sequence of URIs,
being the document URIs of those nodes in the collection that are
document nodes and that have a document URI (other nodes in the
collection are ignored). That is, in the absence of errors,
<code>fn:uri-collection(X)</code> returns the same set of URIs as
<a href="#func-collection">
        <code>fn:collection(X)/fn:document-uri(.)</code>
      </a>,
though possibly in a different order.</rule>
    <rule>The purpose in providing the function, however, is to allow the
URIs of the documents in a collection to be retrieved without
incurring the cost (which might be significant in some
implementations) of dereferencing the URIs to obtain the actual
nodes. Where required, the returned URIs can then be dereferenced
by calling the <code>fn:doc</code> function.</rule>
    <rule>The zero-argument form of the function returns the document URIs
of the document nodes in the default collection.</rule>
    <rule>The single-argument form returns the document URIs of the
document nodes in the collection with a given collection URI. If
the value of the argument is an empty sequence, the action is as
for the zero-argument form of the function. If the argument is a
relative URI, it is resolved against the base URI property of the
static context.</rule>
  </function>
  <function name="generate-id" type="xs:string">
    <signature/>
    <signature>
      <arg name="arg" type="node()?"/>
    </signature>
    <summary>This function returns a string that uniquely identifies a given
node.</summary>
    <rule>If the argument is omitted, it defaults to the context item
(<code>.</code>). The behavior of the function if the argument is
omitted is exactly the same as if the context item had been passed
as the argument.</rule>
    <rule>If the argument is the empty sequence, the result is the
zero-length string.</rule>
    <rule>In other cases, the function returns a string that uniquely
identifies a given node.</rule>
    <rule>The returned identifier <strong>must</strong> consist of ASCII
alphanumeric characters and <strong>must</strong> start with an
alphabetic character. Thus, the string is syntactically an XML
name.</rule>
    <rule>An implementation is free to generate an identifier in any
convenient way provided that it always generates the same
identifier for the same node and that different identifiers are
always generated from different nodes. An implementation is under
no obligation to generate the same identifiers each time a document
is transformed or queried.</rule>
    <example>The primary use case for this function is to generate
hyperlinks. For example, when generating HTML, an anchor for a
given section <code>$sect</code> can be generated by writing (in
either XSLT or XQuery):</example>
    <example>
      <code>&lt;a name="{generate-id($sect)}"/&gt;</code>
    </example>
    <example>and a link to that section can then be produced with code such
as:</example>
    <example>
      <code>see &lt;a
href="#{generate-id($sect)}"&gt;here&lt;/a&gt;</code>
    </example>
    <example>Note that anchors generated in this way will not necessarily be
the same each time a document is republished.</example>
  </function>
  <function name="parse" type="document-node(element(*, xs:untyped))">
    <signature>
      <arg name="arg" type="xs:string"/>
    </signature>
    <signature>
      <arg name="arg" type="xs:string"/>
      <arg name="baseURI" type="xs:string"/>
    </signature>
    <summary>This function takes as input an XML document represented as a
string, and returns the document node at the root of an XDM tree
representing the parsed document.</summary>
    <rule>Schema validation is <em>not</em> invoked, which means that the
nodes in the returned document will all be untyped.</rule>
    <rule>The precise process used to construct the XDM instance is
implementation-defined. In particular, it is implementation-defined
whether DTD validation is invoked, and it is implementation-defined
whether an XML 1.0 or XML 1.1 parser is used.</rule>
    <rule>If the second argument is present then it provides a URI which
will be used as the base URI of the document. This serves both as
the base URI used by the XML parser to resolve relative entity
references within the document, and as the base URI of the document
node that is returned. If the second argument is omitted, then the
static base URI of the <code>fn:parse</code> function call is
used.</rule>
    <rule>The function is <em>not</em> <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>: that is, if the function is called twice with
the same arguments, it is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation-dependent<span class="arrow">·</span>
      </a> whether the same node is returned on both
occasions.</rule>
    <example>The expression
<code>fn:parse("&lt;alpha&gt;abcd&lt;/alpha&gt;")</code> returns a
newly created document node, having an <code>alpha</code> element
as its only child; the <code>alpha</code> element in turn is the
parent of a text node whose string value is
<code>"abcd"</code>.</example>
  </function>
  <function name="serialize" type="xs:string">
    <signature>
      <arg name="arg" type="node()"/>
    </signature>
    <signature>
      <arg name="arg" type="node()"/>
      <arg name="params" type="node()*"/>
    </signature>
    <summary>This function serializes the supplied node <code>$arg</code> as
described in <a href="#">[serialization]</a>, returning the
serialized node as a string.</summary>
    <rule>The node <code>$arg</code> acts as the (singleton) input
sequence to the serialization process.</rule>
    <rule>The single-argument version of this function has the same effect
as the two-argument version called with <code>$params</code> set to
an empty sequence.</rule>
    <rule>The <code>$params</code> argument is used to identify a set of
serialization parameters. These are supplied in the form of a
sequence of nodes, typically element or attribute nodes. Each node
represents one serialization parameter. The parameters are
interpreted as follows:</rule>
    <rule>The final stage of serialization, that is, encoding, is skipped.
If the serializer does not allow this phase to be skipped, then the
sequence of octets returned by the serializer is decoded into a
string by reversing the character encoding performed in the final
stage.</rule>
  </function>
  <function name="position" type="xs:integer">
    <signature/>
    <summary>Returns the context position from the dynamic context.</summary>
    <rule>Returns the context position from the dynamic context. (See
<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.)</rule>
  </function>
  <function name="last" type="xs:integer">
    <signature/>
    <summary>Returns the context size from the dynamic context.</summary>
    <rule>Returns the context size from the dynamic context. (See <a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.)</rule>
    <example>The expression <code>(1 to 20)[fn:last() - 1]</code> returns
<code>19</code>.</example>
  </function>
  <function name="current-dateTime" type="xs:dateTimeStamp">
    <signature/>
    <summary>Returns the current date and time (with timezone).</summary>
    <rule>Returns the current dateTime (with timezone) from the dynamic
context. (See <a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.) This is an
<code>xs:dateTime</code> that is current at some time during the
evaluation of a query or transformation in which
<code>fn:current-dateTime</code> is executed.</rule>
    <rule>This function is <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>. The precise instant during the query or
transformation represented by the value of
<code>fn:current-dateTime()</code> is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <rule>If the implementation supports data types from XSD 1.1 then the
returned value will be an instance of
<code>xs:dateTimeStamp</code>. Otherwise, the only guarantees are
that it will be an instance of <code>xs:dateTime</code> and will
have a timezone component.</rule>
    <example>
      <code>fn:current-dateTime()</code> returns an
<code>xs:dateTimeStamp</code> corresponding to the current date and
time. For example, a call of <code>fn:current-dateTime()</code>
might return <code>2004-05-12T18:17:15.125Z</code> corresponding to
the current time on May 12, 2004 in timezone <code>Z</code>.</example>
  </function>
  <function name="current-date" type="xs:date">
    <signature/>
    <summary>Returns the current date.</summary>
    <rule>Returns <code>xs:date(fn:current-dateTime())</code>. This is an
<code>xs:date</code> (with timezone) that is current at some time
during the evaluation of a query or transformation in which
<code>fn:current-date</code> is executed.</rule>
    <rule>This function is <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>. The precise instant during the query or
transformation represented by the value of
<code>fn:current-date</code> is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <example>
      <code>fn:current-date()</code> returns an <code>xs:date</code>
corresponding to the current date. For example, a call of
<code>fn:current-date()</code> might return
<code>2004-05-12+01:00</code>.</example>
  </function>
  <function name="current-time" type="xs:time">
    <signature/>
    <summary>Returns the current time.</summary>
    <rule>Returns <code>xs:time(fn:current-dateTime())</code>. This is an
<code>xs:time</code> (with timezone) that is current at some time
during the evaluation of a query or transformation in which
<code>fn:current-time</code> is executed.</rule>
    <rule>This function is <a title="stable" class="termref" href="#stable">
        <span class="arrow">·</span>stable<span class="arrow">·</span>
      </a>. The precise instant during the query or
transformation represented by the value of
<code>fn:current-time()</code> is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <example>
      <code>fn:current-time()</code> returns an <code>xs:time</code>
corresponding to the current time. For example, a call of
<code>fn:current-time()</code> might return
<code>23:17:00.000-05:00</code>.</example>
  </function>
  <function name="implicit-timezone" type="xs:dayTimeDuration">
    <signature/>
    <summary>Returns the value of the implicit timezone property from the
dynamic context.</summary>
    <rule>Returns the value of the implicit timezone property from the
dynamic context. Components of the dynamic context are discussed in
<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">
Section C.2 Dynamic Context
Components</a>
      <sup>
        <small>XP</small>
      </sup>.</rule>
  </function>
  <function name="default-collation" type="xs:string">
    <signature/>
    <summary>Returns the value of the default collation property from the
static context.</summary>
    <rule>Returns the value of the default collation property from the
static context. Components of the static context are discussed in
<a href="http://www.w3.org/TR/xpath20/#id-xp-static-context-components">Section
C.1 Static Context Components</a>
      <sup>
        <small>XP</small>
      </sup>.</rule>
  </function>
  <function name="static-base-uri" type="xs:anyURI?">
    <signature/>
    <summary>Returns the value of the Base URI property from the static
context.</summary>
    <rule>The function returns the value of the Base URI property from the
static context. If the Base URI property is undefined, the empty
sequence is returned.</rule>
    <rule>Components of the static context are discussed in <a href="http://www.w3.org/TR/xpath20/#id-xp-static-context-components">Section
C.1 Static Context Components</a>
      <sup>
        <small>XP</small>
      </sup> .</rule>
  </function>
  <function name="function-name" type="xs:QName?">
    <signature>
      <arg name="func" type="function()"/>
    </signature>
    <summary>Returns the name of the function identified by a function
item.</summary>
    <rule>If <code>$func</code> refers to a named function,
<code>fn:function-name($func)</code> returns the name of that
function.</rule>
    <rule>Otherwise (<code>$func</code> refers to an anonymous function),
<code>fn:function-name($func)</code> returns an empty sequence.</rule>
    <rule>The prefix part of the returned QName is <a title="implementation dependent" class="termref" href="#implementation-dependent">
        <span class="arrow">·</span>implementation dependent<span class="arrow">·</span>
      </a>.</rule>
    <example>The expression <code>fn:function-name(fn:contains#2)</code>
returns <a href="#func-QName">
        <code>fn:QName("http://www.w3.org/2005/xpath-functions",
"fn:contains")</code>
      </a>.</example>
    <example>The expression
<code>fn:function-name(function($node){count($node/*})</code>
returns <code>()</code>.</example>
  </function>
  <function name="function-arity" type="xs:integer">
    <signature>
      <arg name="func" type="function()"/>
    </signature>
    <summary>Returns the arity of the function identified by a function
item.</summary>
    <rule>The <code>fn:function-arity</code> function returns the arity
(number of arguments) of the function identified by
<code>$func</code>.</rule>
    <example>The expression <code>fn:function-arity(fn:contains#2)</code>
returns <code>2</code>.</example>
    <example>The expression
<code>fn:function-arity(function($node){name($node})</code> returns
<code>1</code>.</example>
  </function>
</functions>